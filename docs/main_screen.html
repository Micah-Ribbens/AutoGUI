<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Auto-GUI.main_screen API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Auto-GUI.main_screen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import tkinter
from copy import deepcopy

from auto_components.drop_down_menu import DropDownMenu
from auto_components.required_points import RequiredPoint
from auto_features.data_validator import DataValidator
from miscellaneous import important_variables

from auto_components.grid_items import GridItems
from auto_components.input_field import InputField
from auto_components.movable_point import MovablePoint
from auto_components.titled_input_field import TitledInputField
from auto_features.json_file_loader import json_file_loader
from auto_components.point_alterable_fields_frame import PointAlterableFieldsFrame
from auto_components.path_modifying_point import PathModifyingPoint

from auto_components.path_action_point import PathActionPoint
from auto_features.json_file_writer import json_file_writer
from auto_features.path_creation import *

from tkinter import filedialog, messagebox

from tkinter import *
from auto_components.grid import Grid

from miscellaneous.utility_functions import *
from miscellaneous.important_variables import *
from miscellaneous.popup_variables import commands_frame_saver, commands_main_frame


class MainScreen:
    &#34;&#34;&#34;The main screen of the application&#34;&#34;&#34;

    font_size = 22

    # Toolbar
    draw_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Draw&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    update_points_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Update Points&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    clear_field_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Clear Field&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    reset_input_fields_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Reset Fields&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    save_file_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Save File&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    toolbar_height = min(get_measurement(SCREEN_HEIGHT, 15), SCREEN_HEIGHT - FIELD_IMAGE_HEIGHT)
    toolbar_length = get_measurement(SCREEN_LENGTH, 40)
    toolbar_top_edge = SCREEN_HEIGHT - toolbar_height
    popup_windows = []

    # Switching Points Bar
    switching_points_bar_height = get_measurement(SCREEN_HEIGHT, 5)
    selected_point_field = InputField(WINDOW, SMALL_FONT, &#34;1&#34;, True)
    switched_point_field = InputField(WINDOW, SMALL_FONT, &#34;2&#34;, True)
    swap_points_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Swap&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    switching_points_bar_top_edge = SCREEN_HEIGHT - toolbar_height - switching_points_bar_height

    # Point Action Bar
    delete_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Delete&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    move_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Move&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    add_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Add&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    point_bar_length = SCREEN_LENGTH - FIELD_IMAGE_LENGTH
    point_action_bar_height = get_measurement(SCREEN_HEIGHT, 5)
    point_action_bar_top_edge = SCREEN_HEIGHT - toolbar_height - switching_points_bar_height - point_action_bar_height
    point_action_bar_buttons = [delete_button, move_button, add_button]

    # Miscellaneous
    file_name = &#34;&#34;
    selected_point = None
    selected_input_field = None

    # File Menu
    menu = Menu(WINDOW)
    file_menu = Menu(menu)
    menu.add_cascade(label=&#39;File&#39;, menu=file_menu)

    # Point Info:
    path_action_points = []
    path_modifying_points = []
    required_points = []
    current_points_altered_class = PathModifyingPoint
    next_points_altered = {PathModifyingPoint: PathActionPoint, PathActionPoint: RequiredPoint,
                           RequiredPoint: PathModifyingPoint}

    points_altered_to_point_list = {PathActionPoint: path_action_points, PathModifyingPoint: path_modifying_points, RequiredPoint: required_points}
    points_altered_to_frame_button_color = {PathActionPoint: path_action_point_color, PathModifyingPoint: path_modifying_point_color, RequiredPoint: required_point_color}
    points_altered_to_frame_name = {PathActionPoint: &#34;Path Action Point&#34;, PathModifyingPoint: &#34;Path Modifying Point&#34;,
                                    RequiredPoint: &#34;Required Point&#34;}

    # Point Alterable Field Frames:
    path_modifying_point_alterable_fields_frame = PointAlterableFieldsFrame(path_modifying_points, [&#34;Vx&#34;, &#34;Vy&#34;, &#34;x power&#34;])
    path_action_point_alterable_fields_frame = PointAlterableFieldsFrame(path_action_points, [&#34;Speed&#34;, &#34;tValue&#34;, &#34;Command&#34;])
    required_point_alterable_fields_frame = PointAlterableFieldsFrame(required_points, [&#34;tValue&#34;, &#34;Angle&#34;])
    toggle_frame_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Path Action Point&#34;, bg=path_action_point_color, fg=white, font=SMALL_FONT)
    path_action_points_input_fields = []
    path_modifying_points_input_fields = []
    required_points_input_fields = []
    points_altered_to_point_alterable_fields_frame = {PathActionPoint: path_action_point_alterable_fields_frame,
                                                      PathModifyingPoint: path_modifying_point_alterable_fields_frame,
                                                      RequiredPoint: required_point_alterable_fields_frame}
    points_altered_to_points_input_fields = {PathActionPoint: path_action_points_input_fields,
                                             PathModifyingPoint: path_modifying_points_input_fields,
                                             RequiredPoint: required_points_input_fields}
    toggle_frame_button_height = get_measurement(SCREEN_HEIGHT, 4)
    point_alterable_fields_frames_height = point_action_bar_top_edge - toggle_frame_button_height # The Point frames should go down to the top of the Point action bar

    # Commands Frame Dimensions
    commands_frame_length = get_measurement(SCREEN_LENGTH, 15)

    # Initial And End Conditions Frame
    initial_conditions_tab_length = SCREEN_LENGTH - toolbar_length - commands_frame_length
    initial_conditions_tab_left_edge = toolbar_length + commands_frame_length
    initial_angle_field = TitledInputField(WINDOW, SMALL_FONT, &#34;45&#34;, &#34;Initial Angle&#34;, title_field_background_color=blue, title_field_text_color=white)
    initial_speed_field = TitledInputField(WINDOW, SMALL_FONT, &#34;1&#34;, &#34;InitialSpeed&#34;, title_field_background_color=blue, title_field_text_color=white)
    path_is_closed_drop_down_menu = DropDownMenu(WINDOW, 0, [&#34;Path Is Closed&#34;, &#34;Path Is Open&#34;])
    end_angle_field = TitledInputField(WINDOW, SMALL_FONT, &#34;45&#34;, &#34;End Angle&#34;, title_field_background_color=blue, title_field_text_color=white)
    placement_angle_field = TitledInputField(WINDOW, SMALL_FONT, &#34;0&#34;, &#34;Placement Angle&#34;, title_field_background_color=blue, title_field_text_color=white)

    initial_and_end_condition_fields = [initial_angle_field, initial_speed_field, end_angle_field, placement_angle_field]

    # Field Image
    right_field_image = tkinter.PhotoImage(file=right_field_image_path)
    left_field_image = tkinter.PhotoImage(file=left_field_image_path)
    current_field_image = left_field_image
    field_image_bounds = [0, 0, SCREEN_LENGTH - point_bar_length, SCREEN_HEIGHT - toolbar_height]
    image_left_edge = FIELD_IMAGE_LENGTH / 2
    image_top_edge = FIELD_IMAGE_HEIGHT / 2
    field_canvas = None

    # States
    class States:
        DELETION = &#34;DELETION&#34;
        MOVING = &#34;MOVING&#34;
        ADD = &#34;ADD&#34;
        INIT = &#34;INIT&#34;

    point_editing_state = States.ADD
    point_editing_state_to_point_button = {States.DELETION: delete_button, States.MOVING: move_button, States.ADD: add_button}

    right_field_canvas = None
    left_field_canvas = None

    # Path Drawing
    path_line_width = 8
    path_modifying_point_line_width = 5

    # Storing information for saving files
    previous_file_name = &#34;&#34;
    previous_file_path = &#34;&#34;
    key_binding_to_function = {}
    event_key_binding_to_function = {}

    # Input Field Quick Transition Shortcuts
    currently_selected_point_number = 1
    current_input_field_number = 1

    copied_point = None

    def __init__(self):
        &#34;&#34;&#34;Used for setting up the entire GUI&#34;&#34;&#34;

        self.create_file_menu()

        WINDOW.bind(&#34;&lt;Button-1&gt;&#34;, lambda e: self.run_mouse_click(e))

        self.delete_button.configure(command=lambda: self.change_point_editing_state(self.States.DELETION, self.States.ADD))
        self.move_button.configure(command=lambda: self.change_point_editing_state(self.States.MOVING, self.States.INIT))
        self.add_button.configure(command=lambda: self.change_point_editing_state(self.States.ADD, self.States.DELETION))
        self.toggle_frame_button.configure(command=self.toggle_points_alterable_fields_frame)
        self.update_points_button.configure(command=self.update_points)
        self.draw_button.configure(command=self.draw_path)
        self.clear_field_button.configure(command=self.clear_field)
        self.reset_input_fields_button.configure(command=self.reset_all_point_input_fields)
        self.swap_points_button.configure(command=self.swap_points_function)
        self.save_file_button.configure(command=self.quick_save_file)

        commands_frame_saver.create_commands_frame(self.toolbar_length, self.toolbar_top_edge, self.commands_frame_length, self.toolbar_height)
        commands_main_frame.default_show_items()

        # Keyboard Shortcuts
        self.add_all_key_binding_shortcuts()
        self.set_button_colors()
        self.display_everything()

        self.initial_speed_field.error_message_function = DataValidator.get_float_error_message_function(-8, 8)
        self.initial_angle_field.error_message_function = DataValidator.get_float_error_message_function(0, 360)
        self.end_angle_field.error_message_function = DataValidator.get_float_error_message_function(0, 360)
        self.placement_angle_field.error_message_function = DataValidator.get_float_error_message_function(0, 360)

        points.set_points(self.path_modifying_points, self.path_action_points, self.required_points)

    def toggle_points_alterable_fields_frame(self, new_point_class=None):
        &#34;&#34;&#34;Toggles the PointsAlterableFieldsFrame, so it switches to being able to edit PathActionPoints and PathModifyingPoints&#34;&#34;&#34;

        self.run_error_checking()

        if not self.all_input_field_text_is_valid():
            return

        # Resetting the input field the GUI thinks is selected
        self.currently_selected_point_number = 1
        self.current_input_field_number = 1

        self.unselect_input_fields()

        last_frame = self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)
        last_frame.hide()

        self.current_points_altered_class = self.next_points_altered.get(self.current_points_altered_class)

        if new_point_class is not None:
            self.current_points_altered_class = new_point_class

        print(self.current_points_altered_class)
        new_frame = self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)
        new_frame.show()

        frame_name = self.points_altered_to_frame_name.get(self.current_points_altered_class)
        frame_button_color = self.points_altered_to_frame_button_color.get(self.current_points_altered_class)

        self.toggle_frame_button.configure(bg=frame_button_color, text=frame_name)

    def change_point_editing_state(self, point_editing_state, state_after_double_click):
        &#34;&#34;&#34;Changes the point editing state, so it can switch between adding, moving, deleting, and doing nothing with points&#34;&#34;&#34;

        # If the button is a toggle then it should toggle between INIT (doing nothing) and that point_editing_state
        if point_editing_state == self.point_editing_state:
            self.point_editing_state = state_after_double_click

        else:
            self.point_editing_state = point_editing_state

        self.set_button_colors()

    def create_file_menu(self):
        &#34;&#34;&#34;Creates the file menu system that allows the user to navigate between loading and saving files&#34;&#34;&#34;

        self.file_menu.add_command(label=&#34;Load File&#34;, command=self.request_load_file)
        self.file_menu.add_command(label=&#34;Save File As&#34;, command=self.save_file_as)
        self.file_menu.add_command(label=&#34;Right Field Image&#34;, command=lambda: self.draw_field_image(self.right_field_image))
        self.file_menu.add_command(label=&#34;Left Field Image&#34;, command=lambda: self.draw_field_image(self.left_field_image))
        WINDOW.configure(menu=self.menu)

    def create_bottom_bar(self):
        &#34;&#34;&#34;Creates the button bar at the bottom of the screen (updating points, draw button, etc.)&#34;&#34;&#34;

        grid = Grid([0, self.toolbar_top_edge, self.toolbar_length, self.toolbar_height], 1, None)
        grid.turn_into_grid([self.draw_button, self.update_points_button, self.save_file_button,
                             self.clear_field_button, self.reset_input_fields_button], None, None)

    def create_switch_points_bar(self):
        &#34;&#34;&#34;Creates the bar that allows you to switch points around&#34;&#34;&#34;

        grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.switching_points_bar_top_edge, self.point_bar_length, self.switching_points_bar_height], 1, None)
        grid.turn_into_grid([self.selected_point_field, self.switched_point_field, self.swap_points_button], None, None)

    def create_point_action_bar(self):
        &#34;&#34;&#34;Creates the bar that allows you to be able to add, delete, and move points&#34;&#34;&#34;

        grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.point_action_bar_top_edge, self.point_bar_length, self.point_action_bar_height], 1, None)
        grid.turn_into_grid([self.add_button, self.delete_button, self.move_button], None, None)

    def create_point_alterable_fields_frames(self):
        &#34;&#34;&#34;Creates the bar that allows you to be able to modify the field&#39;s attributes like X, Y, Command, etc.&#34;&#34;&#34;

        grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.toggle_frame_button_height, self.point_bar_length, self.point_alterable_fields_frames_height], None, 1)

        # So they have the same dimensions
        grid.turn_into_grid([self.path_modifying_point_alterable_fields_frame], None, None)
        grid.turn_into_grid([self.path_action_point_alterable_fields_frame], None, None)
        grid.turn_into_grid([self.required_point_alterable_fields_frame], None, None)

        self.path_action_point_alterable_fields_frame.hide()
        self.required_point_alterable_fields_frame.hide()
        self.path_modifying_point_alterable_fields_frame.show()

        self.toggle_frame_button.place(x=grid.left_edge, y=0, width=self.point_bar_length, height=self.toggle_frame_button_height)

        frame_name = self.points_altered_to_frame_name.get(self.current_points_altered_class)
        frame_button_color = self.points_altered_to_frame_button_color.get(self.current_points_altered_class)

        self.toggle_frame_button.configure(bg=frame_button_color, text=frame_name)

    def save_file_as(self):
        &#34;&#34;&#34;Saves a new file with the contents of the GUI&#34;&#34;&#34;

        self.run_error_checking()

        if len(self.path_modifying_points) &lt; 2:
            messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
            return

        if not self.all_input_field_text_is_valid():
            return

        file = filedialog.asksaveasfile(mode=&#39;w&#39;, defaultextension=&#34;.json&#34;)

        if file is not None:
            create_file(&#34;swerve_input.txt&#34;)
            create_file(&#34;swerve_output.txt&#34;)

            self.previous_file_name = get_file_name(file)
            self.previous_file_path = file.name

            self.save_file(get_file_name(file), file)


    def quick_save_file(self):
        &#34;&#34;&#34; Saves the file &#39;quickly.&#39; The user only has to hit Ctrl + s or hit the save file button and the previous file
            will be replaced with the new contents&#34;&#34;&#34;

        if self.previous_file_path is not None and self.previous_file_name != &#34;&#34;:
            file = open(self.previous_file_path, &#34;w&#34;)
            self.save_file(self.previous_file_name, file)

        else:
            messagebox.showerror(&#34;ERROR&#34;, &#34;No file has been previous selected. Either Load a File or Save a File as, so &#34;
                                          &#34;I know where to save the files&#34;)

    def save_file(self, file_name, file):
        &#34;&#34;&#34;Saves the file with the contents of the GUI&#34;&#34;&#34;

        create_file(&#34;swerve_input.txt&#34;)
        create_file(&#34;swerve_output.txt&#34;)

        self.run_error_checking()
        if self.all_input_field_text_is_valid():
            self._save_file(file_name, file)

    def _save_file(self, file_name, file):
        &#34;&#34;&#34;Saves the file with the contents of the GUI&#34;&#34;&#34;

        if len(self.path_modifying_points) &lt; 2:
            messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
            return

        start_all_json_contents = {
            &#34;Name&#34;: file_name,
            &#34;Closed&#34;: self.path_is_closed_drop_down_menu.get_selected_item() == &#34;Path Is Closed&#34;,
            &#34;ClosedValue&#34;: self.path_is_closed_drop_down_menu.get_selected_item(),
            &#34;InitialAngle&#34;: self.initial_angle_field.get_text(),
            &#34;EndAngle&#34;: self.end_angle_field.get_text(),
            &#34;InitialSpeed&#34;: self.initial_speed_field.get_text(),
            &#34;offsetAngle&#34;: self.placement_angle_field.get_text()
        }

        initial_path_action_point, first_required_point, last_required_point = self.get_path_action_points_to_reflect_conditions()
        path_action_points = copy_list(self.path_action_points)
        path_action_points.append(initial_path_action_point)

        json_file_writer.write_positions_to_file()

        if len(points.path_action_points) &lt;= 1:
            first_path_action_point_coordinates = get_closest_path_point(path_action_points[0].get_field_left_edge(),
                                                                         path_action_points[0].get_field_top_edge())

            left_edge, top_edge = json_file_writer.get_next_path_action_point_coordinates(first_path_action_point_coordinates)
            additional_path_action_point = PathActionPoint(None, None, False)

            additional_path_action_point.set_field_left_edge(left_edge)
            additional_path_action_point.set_field_top_edge(top_edge)
            additional_path_action_point.set_speed(path_action_points[0].get_speed())
            additional_path_action_point.set_command(&#34;none&#34;)
            additional_path_action_point.is_needed = False

            path_action_points.append(additional_path_action_point)


        placement_angle = float(self.placement_angle_field.get_text())
        json_file_writer.write_file(file, self.path_modifying_points,
                                    path_action_points, start_all_json_contents, first_required_point,
                                    last_required_point, placement_angle)

        first_required_point.destroy()
        last_required_point.destroy()
        initial_path_action_point.destroy()

        file.close()

    def get_path_action_points_to_reflect_conditions(self):
        &#34;&#34;&#34;
            Returns:
                list[MovablePoint]: {initial_path_action_point, first_required_point, last_required_point}; The updated control points
                that reflect what was entered in the conditions tab + the first and last required point&#34;&#34;&#34;

        last_path_modifying_point = self.path_modifying_points[len(self.path_modifying_points) - 1]
        # The first point on the path must have a path modifying point, so the robot has the information to start the path
        initial_required_point = self.get_required_point_at_path_modifying_point(self.path_modifying_points[0], float(self.initial_angle_field.get_text()), 0)
        last_required_point = self.get_required_point_at_path_modifying_point(last_path_modifying_point, float(self.end_angle_field.get_text()), len(points.path_modifying_points) - 1)

        initial_path_action_point: PathActionPoint = self.get_path_action_point_point_at_path_modifying_point(self.path_modifying_points[0], 0)

        additional_path_action_points = [initial_path_action_point, initial_required_point, last_required_point]

        for path_action_point in additional_path_action_points:
            path_action_point.is_needed = False

        return [initial_path_action_point, initial_required_point, last_required_point]

    def get_required_point_at_path_modifying_point(self, path_modifying_point, angle, path_modifying_point_path_index):
        &#34;&#34;&#34;
            Returns:
                PathActionPoint: a PathActionPoint that is at the same position of the &#39;path_modifying_point&#39; provided&#34;&#34;&#34;

        # None of these numbers matter because this PathActionPoint won&#39;t be on the screen
        required_point = RequiredPoint(None, 0, is_on_screen=False)

        required_point.set_field_left_edge(path_modifying_point.get_field_left_edge())
        required_point.set_field_top_edge(path_modifying_point.get_field_top_edge())
        required_point.set_angle(angle)
        required_point.set_t_value(path_modifying_point_path_index)

        return required_point

    def get_path_action_point_point_at_path_modifying_point(self, path_modifying_point, path_modifying_point_path_index):
        &#34;&#34;&#34;
            Returns:
                PathActionPoint: a PathActionPoint that is at the same position of the &#39;path_modifying_point&#39; provided&#34;&#34;&#34;

        # None of these numbers matter because this PathActionPoint won&#39;t be on the screen
        path_action_point = PathActionPoint(None, 0, is_on_screen=False)

        path_action_point.set_field_left_edge(path_modifying_point.get_field_left_edge())
        path_action_point.set_field_top_edge(path_modifying_point.get_field_top_edge())
        path_action_point.set_t_value(path_modifying_point_path_index)
        path_action_point.set_command(&#34;none&#34;)
        path_action_point.set_speed(float(self.initial_speed_field.get_text()))

        return path_action_point

    def display_everything(self):
        &#34;&#34;&#34;Allows the user to be able to interact with the GUI&#34;&#34;&#34;

        # Creating all the grids on the screen (the &#39;bars&#39;)
        self.create_bottom_bar()
        self.create_point_action_bar()
        self.create_point_alterable_fields_frames()
        self.create_switch_points_bar()
        self.create_initial_conditions_bar()

        # Creating the canvas that holds all the points and the field image
        canvas_length = SCREEN_LENGTH - self.point_bar_length
        canvas_height = SCREEN_HEIGHT - self.toolbar_height

        self.field_canvas = Canvas(master=WINDOW, width=canvas_length,
                                        height=canvas_height, bg=blue)

        self.draw_field_image()
        self.field_canvas.place(x=0, y=0)

    def draw_field_image(self, field_image=None):
        &#34;&#34;&#34;Displays the current field image&#34;&#34;&#34;

        if field_image is not None and field_image == self.right_field_image:
            important_variables.CENTER_OF_FIELD_HORIZONTAL_OFFSET = 0

        elif field_image is not None:
            important_variables.CENTER_OF_FIELD_HORIZONTAL_OFFSET = FIELD_IMAGE_LENGTH * PIXELS_TO_METERS_MULTIPLIER  # pixels -&gt; meters

        if field_image is not None and self.current_field_image != field_image:
            self.current_field_image = field_image

            for point in self.required_points + self.path_action_points + self.path_modifying_points:

                # Mirroring all the points along the y axis
                left_edge = point.get_field_left_edge() * -1
                point.set_field_left_edge(left_edge)

            for points_list in [self.path_modifying_points, self.path_action_points, self.required_points]:
                self.update_points(points_list)

        self.field_canvas.create_image(self.image_left_edge, self.image_top_edge, image=self.current_field_image)

    def create_initial_conditions_bar(self):
        &#34;&#34;&#34;Creates the bar for the conditions&#34;&#34;&#34;

        grid = Grid([self.initial_conditions_tab_left_edge, self.toolbar_top_edge, self.initial_conditions_tab_length, self.toolbar_height], 1, None)
        grid.turn_into_grid(self.initial_and_end_condition_fields + [self.path_is_closed_drop_down_menu], None, None)

    def create_point(self, mouse_left_edge, mouse_top_edge):
        &#34;&#34;&#34;Puts a new point onto the screen&#34;&#34;&#34;

        min_left_edge, min_top_edge, length, height = self.field_image_bounds
        max_left_edge = min_left_edge + length
        max_top_edge = min_top_edge + height

        is_within_horizontal_bounds = mouse_left_edge &gt;= min_left_edge and mouse_left_edge &lt;= max_left_edge
        is_within_vertical_bounds = mouse_top_edge &gt;= min_top_edge and mouse_top_edge &lt;= max_top_edge

        if is_within_horizontal_bounds and is_within_vertical_bounds:
            # Initializing the point
            point = self.current_points_altered_class(self.point_click_function, len(self.points_list) + 1)

            point_left_edge = mouse_left_edge - point.base_length / 2
            point_top_edge = mouse_top_edge - point.base_height / 2

            point.place(want_to_update_input_fields=True, x=point_left_edge, y=point_top_edge, width=point.base_length, height=point.base_height)

            self.points_list.append(point)
            point.set_order_position(len(self.points_list))
            self.add_needed_point_creation_information(point)
            self.point_alterable_fields_frame.update()
    def unselect_input_fields(self, selected_input_field=None):
        &#34;&#34;&#34;Makes all the points except the &#39;selected_input_field&#39; become unselected&#34;&#34;&#34;

        for input_field in self.points_input_fields:
            if selected_input_field is None:
                input_field.set_is_selected(False)

            # Meaning we can now check if the input_field is the same as the selected_input_field because the input_field
            # is not None
            elif input_field != selected_input_field:
                input_field.set_is_selected(False)

        for point in self.points_list:
            if selected_input_field is None:
                point.unselect()

            # Meaning we can now check if the input_field is the same as the selected_input_field because the input_field
            # is not None
            elif selected_input_field.belongs_to != point:
                point.unselect()

        self.selected_input_field = None

    def update_input_fields(self):
        &#34;&#34;&#34;So when a point is either added or deleted all the fields are recalculated to reflect the points&#34;&#34;&#34;

        # So there are no more input fields; then all the input fields can be populated
        # Creating a new variable, so the names don&#39;t conflict with the function name
        points_input_fields = self.points_input_fields
        points_input_fields[:] = []

        for point in self.points_list:
            points_input_fields += point.get_input_fields()

    def handle_input_field_click(self, selected_input_field, want_error_checking=True):
        &#34;&#34;&#34;Makes the input field become selected and the point that input field belongs to selected (all others are unselected)&#34;&#34;&#34;

        if want_error_checking:
            self.run_error_checking()

        selected_point = selected_input_field.belongs_to
        self.currently_selected_point_number = self.points_list.index(selected_point) + 1
        self.current_input_field_number = selected_point.get_input_fields().index(selected_input_field) + 1

        self.unselect_input_fields(selected_input_field)

        # Once all the input field&#39;s are unselected then make the &#39;selected_input_field&#39; selected
        selected_input_field.set_is_selected(True)
        selected_input_field.get_belongs_to().select()
        self.selected_input_field = selected_input_field

    # Click Functions
    def swap_points_function(self):
        &#34;&#34;&#34;Swaps the points&#34;&#34;&#34;

        # Indexes and the point numbers are of a difference of 1
        point_index = int(self.selected_point_field.get_text()) - 1
        new_index = int(self.switched_point_field.get_text()) - 1

        point_index_is_valid = point_index &gt;= 0 and point_index &lt; len(self.points_list)
        new_index_is_valid = new_index &gt;= 0 and new_index &lt; len(self.points_list)

        if point_index == new_index or not point_index_is_valid or not new_index_is_valid:
            messagebox.showerror(&#34;ERROR&#34;, f&#34;Can not swap points when invalid point order numbers are inputted. Values must be between 1 and {len(self.points_list)}&#34;)

        else:
            # Swaps the &#39;backend&#39; position of the points
            swap_list_items(self.points_list, point_index, new_index)
            self.point_alterable_fields_frame.update()

    def get_points_list(self, point):
        &#34;&#34;&#34;
            Returns:
                MovablePoint[]: the points list that the point belongs to (PathModifyingPoint, PathActionPoint, etc.)&#34;&#34;&#34;

        point_type = type(point)

        return self.points_altered_to_point_list.get(point_type)

    def get_index_of_point(self, point, points_list):
        &#34;&#34;&#34;
            Returns:
                int: the index of the point within the points list gotten from get_points_list()&#34;&#34;&#34;

        return points_list.index(point)

    def point_click_function(self, point):
        &#34;&#34;&#34; Runs different things depending on what point_editing_state the GUI is in when the point was clicked:
            ADD: Adds a point
            MOVING: Selects a point
            DELETION: Deletes a point
        &#34;&#34;&#34;

        points_list = self.get_points_list(point)
        index_of_point = self.get_index_of_point(point, points_list)

        if self.point_editing_state == self.States.DELETION:
            self.delete_point(index_of_point, points_list)

        if self.point_editing_state == self.States.MOVING:
            self.selected_point = point
            self.selected_point.select()

    def set_button_colors(self):
        &#34;&#34;&#34;Sets the colors of the add, move, delete buttons; called upon point_editing_state change&#34;&#34;&#34;

        for button in self.point_action_bar_buttons:
            button.configure(bg=pleasing_green)

        point_button = self.point_editing_state_to_point_button.get(self.point_editing_state)

        # If the point_editing_state is in INIT then there will be no point button causing an error
        if point_button is not None:
            point_button.configure(bg=dark_green)

    def run_mouse_click(self, event):
        &#34;&#34;&#34;Creates a point if the point_editing_state is ADD and moves a point if the point_editing_state is MOVE and a point is selected&#34;&#34;&#34;

        mouse_left_edge, mouse_top_edge = get_mouse_position()

        if self.point_editing_state == self.States.ADD:
            self.create_point(mouse_left_edge, mouse_top_edge)

        if self.point_editing_state == self.States.MOVING and self.selected_point is not None:
            self.selected_point.place(True, x=mouse_left_edge, y=mouse_top_edge)
            self.selected_point.unselect()
            self.selected_point = None

    def all_input_field_text_is_valid(self):
        &#34;&#34;&#34;
            Returns:
                bool: whether the text in the InputField&#39;s are valid&#34;&#34;&#34;

        if not WANT_ERROR_CHECKING:
            return True

        return self.get_error_message() is None

    def run_error_checking(self):
        &#34;&#34;&#34;Runs the error checking for all the input fields&#34;&#34;&#34;

        error_message = self.get_error_message()

        if error_message is not None and WANT_ERROR_CHECKING:
            messagebox.showerror(&#34;ERROR&#34;, error_message)

            # raise ValueError(&#34;There was bad input! Stopping the program&#34;)

    def get_error_message(self):
        &#34;&#34;&#34;
            Returns:
                str: the error message of the input field&#39;s if the data was invalid (None if it is valid)&#34;&#34;&#34;

        return_value = None

        for point in self.points_list:
            for input_field in point.get_input_fields():
                error_message = input_field.get_error_message()

                if error_message is not None:
                    return_value = error_message
                    input_field.get_error_message()
                    break

            if return_value is not None:
                break

        for input_field in self.initial_and_end_condition_fields:
            error_message = input_field.get_error_message()

            if error_message is not None and return_value is None:
                return_value = error_message
                break

        return return_value

    def update_points(self, points_list=None):
        &#34;&#34;&#34;Updates the points, so they reflect what the input field&#39;s have&#34;&#34;&#34;

        self.run_error_checking()

        if not self.all_input_field_text_is_valid():
            return

        if len(points.path_points) == 0:
            messagebox.showerror(&#34;ERROR&#34;, &#34;Make sure you have drawn the path before trying to update the points&#34;)
            return

        path_modifying_point_path_indexes = get_path_modifying_point_path_indexes()
        update_path_action_and_required_point_location(points.path_action_points, points.required_points,
                                                       path_modifying_point_path_indexes, points.path_modifying_points)

        points_list = self.points_list if points_list is None else points_list

        for point in points_list:
            point.default_update_coordinates()

    def reset_point_input_fields(self, points):
        &#34;&#34;&#34;Changes the input fields, so they reflect the points position on the screen&#34;&#34;&#34;

        for point in points:
            point.update_input_fields()

    def reset_all_point_input_fields(self):
        &#34;&#34;&#34;Changes all the point input fields, so they reflect the points position on the screen&#34;&#34;&#34;

        self.reset_point_input_fields(self.path_action_points)
        self.reset_point_input_fields(self.path_modifying_points)
        self.reset_point_input_fields(self.required_points)

        self.reset_point_input_fields(self.path_action_points)
        self.reset_point_input_fields(self.path_modifying_points)
        self.reset_point_input_fields(self.required_points)

    def clear_field(self):
        &#34;&#34;&#34;Clears the entire field of points and the path&#34;&#34;&#34;

        for point in self.path_action_points + self.path_modifying_points + self.required_points:
            point.destroy()

        # So they don&#39;t reassigned to a new spot in memory messing up the pointer the frames have to the lists
        self.path_action_points[:] = []
        self.path_modifying_points[:] = []
        self.required_points[:] = []

        self.field_canvas.delete(&#34;all&#34;)
        self.draw_field_image()

        # Updates the frames, so they contain the points data
        self.path_action_point_alterable_fields_frame.update()
        self.path_modifying_point_alterable_fields_frame.update()

    def change_point_order(self, is_up):
        &#34;&#34;&#34;Moves the order of the currently selected point (1 -&gt; 2)&#34;&#34;&#34;

        if self.selected_input_field is not None:
            point = self.selected_input_field.get_belongs_to()
            point_index, new_index = self.get_point_indexes(point, is_up)

            # Swaps the &#39;backend&#39; position of the points
            swap_list_items(self.points_list, point_index, new_index)
            self.point_alterable_fields_frame.update()

    def get_point_indexes(self, selected_point, is_up):
        &#34;&#34;&#34;
            Returns:
                 int: the new index of the point&#34;&#34;&#34;

        point_index = selected_point.get_order_position() - 1

        next_index = get_next_index(len(self.points_list) - 1, point_index)
        previous_index = get_previous_index(len(self.points_list) - 1, point_index)
        new_index = next_index if is_up else previous_index

        return [point_index, new_index]

    def draw_path(self):
        &#34;&#34;&#34;Writes the data to the file, which calls AutoFollower.jar then it draws the points from AutoFollower.jar&#34;&#34;&#34;

        self.run_error_checking()

        if len(self.path_modifying_points) &lt; 2:
            messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
            return

        if self.all_input_field_text_is_valid():
            create_file(&#34;swerve_input.txt&#34;)
            create_file(&#34;swerve_output.txt&#34;)

            # So all the lines are deleted and the image is still on the canvas
            self.field_canvas.delete(&#34;all&#34;)
            self.draw_field_image()
            json_file_writer.write_positions_to_file()
            self.update_point_information()

            draw_path_lines(self.field_canvas, self.path_modifying_point_line_width, self.path_line_width)
            self.draw_robot_angle_lines()

            self.update_points()

    def update_point_information(self):
        &#34;&#34;&#34;Updates all the point information, so drawing the path lines will work correctly&#34;&#34;&#34;

        unused, first_required_point, last_required_point = self.get_path_action_points_to_reflect_conditions()
        path_action_points = [first_required_point] + points.path_action_points + [last_required_point]
        required_points = [first_required_point] + self.required_points + [last_required_point]

        update_path_modifying_point_information(path_action_points=path_action_points, required_points=required_points)
        first_required_point.destroy()
        last_required_point.destroy()

    def draw_robot_angle_lines(self):
        &#34;&#34;&#34;Draws the robot angle at each control point&#34;&#34;&#34;

        for path_modifying_point in self.path_modifying_points:
            angle = path_modifying_point.get_angle_at_point()
            point2_left_edge = path_modifying_point.get_left_edge() + math.cos(angle) * ROBOT_ANGLE_LINE_LENGTH

            y_distance = math.sin(angle) * ROBOT_ANGLE_LINE_LENGTH
            point2_top_edge = path_modifying_point.get_top_edge() - y_distance

            self.field_canvas.create_line([path_modifying_point.get_left_edge(), path_modifying_point.get_top_edge()], [point2_left_edge, point2_top_edge],
                                          fill=ROBOT_ANGLE_LINE_COLOR, width=ROBOT_ANGLE_LINE_WIDTH)

    # Loading in from files
    def request_load_file(self):
        &#34;&#34;&#34;Loads a file onto the GUI&#34;&#34;&#34;

        file = filedialog.askopenfile(mode=&#39;r&#39;)

        if file is not None:
            self.load_file(file)

    def load_file(self, file):
        &#34;&#34;&#34;Loads the file onto the GUI&#34;&#34;&#34;

        json_contents = json.load(file)
        self.previous_file_path = file.name
        self.previous_file_name = get_file_name(file)

        file.close()

        # Setting the text field information to reflect the file
        self.placement_angle_field.set_text(json_contents[&#34;offsetAngle&#34;])
        self.initial_speed_field.set_text(json_contents[&#34;InitialSpeed&#34;])
        self.end_angle_field.set_text(json_contents[&#34;EndAngle&#34;])
        self.initial_angle_field.set_text(json_contents[&#34;InitialAngle&#34;])
        self.path_is_closed_drop_down_menu.set_selected_item(json_contents[&#34;ClosedValue&#34;])

        # Updating the points to reflect the file
        self.update_points_to_reflect_loaded_file(json_contents)
        self.add_needed_point_creation_information_for_all_points()

    def add_needed_point_creation_information_for_all_points(self):
        &#34;&#34;&#34; Adds all the information the other parts of the code need for a point to be created for all the points (
            for each point it calls add_needed_point_creation_information())&#34;&#34;&#34;

        for point in self.path_modifying_points + self.path_action_points:
            self.add_needed_point_creation_information(point)

        self.path_action_point_alterable_fields_frame.update()
        self.path_modifying_point_alterable_fields_frame.update()

    def add_needed_point_creation_information(self, point):
        &#34;&#34;&#34;Adds all the information the other parts of the code need for a point to be created&#34;&#34;&#34;

        point.set_input_fields_command(self.handle_input_field_click)
        self.update_input_fields()

    def update_points_to_reflect_loaded_file(self, json_contents):
        &#34;&#34;&#34;So the GUI reflects what is in the file (has to be delayed because it takes a while for the GUI to update and load the file)&#34;&#34;&#34;

        self.clear_field()

        json_file_loader.set_all_points_to_reflect_json_file(self.path_modifying_points, self.path_action_points,
                                                             self.required_points, json_contents, self.point_click_function)

        # So the points change location based on what is in the input fields
        self.update_points(self.path_action_points)
        self.update_points(self.path_modifying_points)
        self.update_points(self.required_points)

        # Otherwise the frame information does not update correctly
        self.toggle_points_alterable_fields_frame()
        self.toggle_points_alterable_fields_frame()
        self.toggle_points_alterable_fields_frame()

    def change_input_field_selection(self, event):
        &#34;&#34;&#34;Changes the selected input field depending on what key was pressed

            Args:
                event (str): the event name. Here are all the possible values:
                &#39;Up&#39; -&gt; Selects the next input field above the current one (belongs to the previous way point)
                &#39;Down&#39; -&gt; Selects the next input field below the current one (belongs to the next way point)
                &#39;Left&#39; -&gt; Selects the next input field to the right of the current one (belongs to the current way point)
                &#39;Right&#39; -&gt; Selects the previous input field to the left the current one (belongs to the current way point)
            
            
            Returns:
                None
        &#34;&#34;&#34;

        self.run_error_checking()

        if not self.all_input_field_text_is_valid():
            return

        if self.currently_selected_point_number &gt; len(self.points_list) or self.currently_selected_point_number &lt; 1:
            messagebox.showerror(&#34;ERROR&#34;, &#34;Cannot Switch input fields because they do not exist!!!&#34;)
            return

        valid_event_types = [&#34;Up&#34;, &#34;Down&#34;, &#34;Left&#34;, &#34;Right&#34;, &#34;Beginning&#34;, &#34;End&#34;]

        if not valid_event_types.__contains__(event):
            raise ValueError(&#34;Valid Data was not inputted!!!&#34;)

        user_modifiable_fields = self.get_user_modifiable_fields(self.currently_selected_point_number)
        # Modifying the numbers, so the selected input_field is not out of bounds of the input_fields on the screen
        max_input_field_number = len(user_modifiable_fields)

        if event == &#34;Up&#34;:
            self.currently_selected_point_number -= 1

        if event == &#34;Down&#34;:
            self.currently_selected_point_number += 1

        if event == &#34;Left&#34;:
            self.current_input_field_number -= 1

        if event == &#34;Right&#34;:
            self.current_input_field_number += 1

        if event == &#34;Beginning&#34;:
            self.current_input_field_number = 1

        if event == &#34;End&#34;:
            self.current_input_field_number = max_input_field_number

        if self.current_input_field_number &gt; max_input_field_number:
            self.current_input_field_number = 1
            self.currently_selected_point_number += 1

        if self.current_input_field_number &lt;= 0:
            self.current_input_field_number = max_input_field_number
            self.currently_selected_point_number -= 1

        self.make_input_field_selection_valid()
    def make_input_field_selection_valid(self):
        &#34;&#34;&#34;Makes sure where the GUI thinks the next input field selection is valid&#34;&#34;&#34;

        # Making sure the currently selected points are cyclic 0 -&gt; max_index -&gt; 0 -&gt; etc.
        max_selected_point_number = len(self.points_list)

        if self.currently_selected_point_number &gt; max_selected_point_number:
            self.currently_selected_point_number = 1

        if self.currently_selected_point_number &lt;= 0:
            self.currently_selected_point_number = max_selected_point_number

        self.focus_on_input_field(self.currently_selected_point_number, self.current_input_field_number)

    def add_all_key_binding_shortcuts(self):
        &#34;&#34;&#34;Adds all the key binding shortcuts to the Auto GUI&#34;&#34;&#34;

        key_binding_to_function = {}

        key_binding_to_function[&#34;&lt;Control-a&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(PathModifyingPoint)
        key_binding_to_function[&#34;&lt;Control-c&gt;&#34;] = lambda event: self.copy_point()
        key_binding_to_function[&#34;&lt;Control-d&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(RequiredPoint)
        key_binding_to_function[&#34;&lt;KeyPress-d&gt;&#34;] = lambda event: self.draw_path()
        key_binding_to_function[&#34;&lt;KeyPress-e&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.MOVING,
                                                                                  self.States.MOVING)
        key_binding_to_function[&#34;&lt;KeyPress-f&gt;&#34;] = lambda event: self.save_file_as()
        key_binding_to_function[&#34;&lt;KeyPress-g&gt;&#34;] = lambda event: self.request_load_file()

        key_binding_to_function[&#34;&lt;KeyPress-h&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Left&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-i&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Beginning&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-j&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Down&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-k&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Up&#34;)
        key_binding_to_function[&#34;&lt;Control-l&gt;&#34;] = lambda event: self.request_load_file()
        key_binding_to_function[&#34;&lt;KeyPress-l&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Right&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-o&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;End&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-q&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.ADD,
                                                                                   self.States.ADD)
        key_binding_to_function[&#34;&lt;KeyPress-r&gt;&#34;] = lambda event: self.reset_all_point_input_fields()
        key_binding_to_function[&#34;&lt;KeyPress-s&gt;&#34;] = lambda event: self.quick_save_file()
        key_binding_to_function[&#34;&lt;Control-s&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(PathActionPoint)
        key_binding_to_function[&#34;&lt;Control-v&gt;&#34;] = lambda event: self.paste_point()
        key_binding_to_function[&#34;&lt;KeyPress-u&gt;&#34;] = lambda event: self.clear_field()
        key_binding_to_function[&#34;&lt;KeyPress-w&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.DELETION,
                                                                                               self.States.DELETION)
        key_binding_to_function[&#34;&lt;KeyPress-z&gt;&#34;] = lambda event: self.swap_points_function()

        key_binding_to_function[&#34;&lt;KeyPress-Return&gt;&#34;] = lambda event: self.update_points(self.points_list)
        key_binding_to_function[&#34;&lt;Control-space&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame()
        key_binding_to_function[&#34;&lt;Control-BackSpace&gt;&#34;] = lambda event: self.delete_point()
        key_binding_to_function[&#34;&lt;KeyPress-Up&gt;&#34;] = lambda event: self.change_point_order(False)
        key_binding_to_function[&#34;&lt;KeyPress-Down&gt;&#34;] = lambda event: self.change_point_order(True)

        key_binding_to_function[&#34;&lt;KeyPress-Tab&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Right&#34;)

        for key_binding in key_binding_to_function.keys():
            WINDOW.bind(key_binding, key_binding_to_function.get(key_binding))

            # Finding the event_key_binding because the event_key_binding has different information than the key_binding.
            # For instance, key_binding is &#39;&lt;KeyPress-u&gt;&#39; while event_key_binding is &#39;u&#39;
            first_dash_index = key_binding.index(&#34;-&#34;)
            event_key_binding = key_binding[first_dash_index + 1:]
            event_key_binding = event_key_binding[:-1] # The last character of the string is &#39;&gt;&#39; which is not needed

            important_variables.all_key_bindings.append(event_key_binding)

    def focus_on_input_field(self, point_number, input_field_number):
        &#34;&#34;&#34;Moves the mouse to the input field and the desired location&#34;&#34;&#34;

        user_modifiable_field = self.get_user_modifiable_fields(point_number)[input_field_number - 1]

        user_modifiable_field.focus_force()
        self.handle_input_field_click(user_modifiable_field, want_error_checking=False)

    def get_user_modifiable_fields(self, point_number):
        &#34;&#34;&#34;
            Returns:
                list[object] the fields the user can modify for that point number (in the PointAlterableFieldsFrame)&#34;&#34;&#34;

        point_index = point_number - 1
        point: MovablePoint = self.points_list[point_index]

        user_modifiable_fields = point.get_input_fields()

        return user_modifiable_fields

    def copy_point(self):
        &#34;&#34;&#34;Copies the currently selected point into the &#39;clipboard&#39;&#34;&#34;&#34;

        point_index = self.currently_selected_point_number - 1
        self.copied_point = self.points_list[point_index]

    def paste_point(self):
        &#34;&#34;&#34;Pastes the copied_point into the GUI&#34;&#34;&#34;

        new_point = self.current_points_altered_class(self.point_click_function,
                                                      self.currently_selected_point_number + 1)

        if self.copied_point is not None:
            # Making the input fields alike
            copied_point_input_fields = self.copied_point.get_input_fields()
            new_point_input_fields = new_point.get_input_fields()

            for x in range(len(copied_point_input_fields)):
                copied_point_input_field = copied_point_input_fields[x]
                new_point_input_field = new_point_input_fields[x]

                new_point_input_field.set_text(copied_point_input_field.get_text())

        # Update the GUI
        self.points_list.insert(self.currently_selected_point_number, new_point)
        self.add_needed_point_creation_information(new_point)
        self.point_alterable_fields_frame.update()
        self.change_input_field_selection(&#34;Down&#34;)
        new_point.place(True, x=self.copied_point.get_left_edge(), y=self.copied_point.get_top_edge())

    def delete_point(self, index_of_point=None, points_list=None):
        &#34;&#34;&#34;Deletes the currently selected point&#34;&#34;&#34;

        deletion_is_valid = True

        if index_of_point is None:
            index_of_point = self.currently_selected_point_number - 1

            # It is possible to hit the keyboard shortcut and not be able to delete validly
            index_is_valid = index_of_point &gt;= 0 and index_of_point &lt; len(self.points_list) and len(self.points_list) &gt;= 0

            deletion_is_valid = index_is_valid and self.selected_input_field is not None

        if points_list is None:
            points_list = self.points_list

        if deletion_is_valid:
            point = points_list[index_of_point]
            del points_list[index_of_point]
            self.path_action_point_alterable_fields_frame.update()
            self.path_modifying_point_alterable_fields_frame.update()
            self.required_point_alterable_fields_frame.update()
            point.destroy()

            self.update_input_fields()

        # Makes sure we have a input field selected
        if deletion_is_valid and len(self.points_list) &gt;= 1:
            self.make_input_field_selection_valid()

    @property
    def points_list(self):
        &#34;&#34;&#34;The current points being modified that belong to the PointAlterableFieldsFrame&#34;&#34;&#34;
        
        return self.points_altered_to_point_list.get(self.current_points_altered_class)

    @property
    def point_alterable_fields_frame(self):
        &#34;&#34;&#34;The current PointAlterableFieldsFrame that is on the screen&#34;&#34;&#34;
        
        return self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)

    @property
    def points_input_fields(self):
        &#34;&#34;&#34;The points input fields that are currently on the screen that belong to the PointAlterableFieldsFrame&#34;&#34;&#34;
        
        return self.points_altered_to_points_input_fields.get(self.current_points_altered_class)

    @property
    def current_point_list(self):
        &#34;&#34;&#34;The points list that is currently in use&#34;&#34;&#34;
        
        # First number in Point states signifies if it is the path modifying points list being modified
        return self.points_altered_to_point_list.get(self.current_points_altered_class)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Auto-GUI.main_screen.MainScreen"><code class="flex name class">
<span>class <span class="ident">MainScreen</span></span>
</code></dt>
<dd>
<div class="desc"><p>The main screen of the application</p>
<p>Used for setting up the entire GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainScreen:
    &#34;&#34;&#34;The main screen of the application&#34;&#34;&#34;

    font_size = 22

    # Toolbar
    draw_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Draw&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    update_points_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Update Points&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    clear_field_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Clear Field&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    reset_input_fields_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Reset Fields&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    save_file_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Save File&#34;, bg=pleasing_green, fg=white, font=TINY_FONT)
    toolbar_height = min(get_measurement(SCREEN_HEIGHT, 15), SCREEN_HEIGHT - FIELD_IMAGE_HEIGHT)
    toolbar_length = get_measurement(SCREEN_LENGTH, 40)
    toolbar_top_edge = SCREEN_HEIGHT - toolbar_height
    popup_windows = []

    # Switching Points Bar
    switching_points_bar_height = get_measurement(SCREEN_HEIGHT, 5)
    selected_point_field = InputField(WINDOW, SMALL_FONT, &#34;1&#34;, True)
    switched_point_field = InputField(WINDOW, SMALL_FONT, &#34;2&#34;, True)
    swap_points_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Swap&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    switching_points_bar_top_edge = SCREEN_HEIGHT - toolbar_height - switching_points_bar_height

    # Point Action Bar
    delete_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Delete&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    move_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Move&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    add_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Add&#34;, bg=pleasing_green, fg=white, font=SMALL_FONT)
    point_bar_length = SCREEN_LENGTH - FIELD_IMAGE_LENGTH
    point_action_bar_height = get_measurement(SCREEN_HEIGHT, 5)
    point_action_bar_top_edge = SCREEN_HEIGHT - toolbar_height - switching_points_bar_height - point_action_bar_height
    point_action_bar_buttons = [delete_button, move_button, add_button]

    # Miscellaneous
    file_name = &#34;&#34;
    selected_point = None
    selected_input_field = None

    # File Menu
    menu = Menu(WINDOW)
    file_menu = Menu(menu)
    menu.add_cascade(label=&#39;File&#39;, menu=file_menu)

    # Point Info:
    path_action_points = []
    path_modifying_points = []
    required_points = []
    current_points_altered_class = PathModifyingPoint
    next_points_altered = {PathModifyingPoint: PathActionPoint, PathActionPoint: RequiredPoint,
                           RequiredPoint: PathModifyingPoint}

    points_altered_to_point_list = {PathActionPoint: path_action_points, PathModifyingPoint: path_modifying_points, RequiredPoint: required_points}
    points_altered_to_frame_button_color = {PathActionPoint: path_action_point_color, PathModifyingPoint: path_modifying_point_color, RequiredPoint: required_point_color}
    points_altered_to_frame_name = {PathActionPoint: &#34;Path Action Point&#34;, PathModifyingPoint: &#34;Path Modifying Point&#34;,
                                    RequiredPoint: &#34;Required Point&#34;}

    # Point Alterable Field Frames:
    path_modifying_point_alterable_fields_frame = PointAlterableFieldsFrame(path_modifying_points, [&#34;Vx&#34;, &#34;Vy&#34;, &#34;x power&#34;])
    path_action_point_alterable_fields_frame = PointAlterableFieldsFrame(path_action_points, [&#34;Speed&#34;, &#34;tValue&#34;, &#34;Command&#34;])
    required_point_alterable_fields_frame = PointAlterableFieldsFrame(required_points, [&#34;tValue&#34;, &#34;Angle&#34;])
    toggle_frame_button = Button(WINDOW, compound=tkinter.CENTER, text=&#34;Path Action Point&#34;, bg=path_action_point_color, fg=white, font=SMALL_FONT)
    path_action_points_input_fields = []
    path_modifying_points_input_fields = []
    required_points_input_fields = []
    points_altered_to_point_alterable_fields_frame = {PathActionPoint: path_action_point_alterable_fields_frame,
                                                      PathModifyingPoint: path_modifying_point_alterable_fields_frame,
                                                      RequiredPoint: required_point_alterable_fields_frame}
    points_altered_to_points_input_fields = {PathActionPoint: path_action_points_input_fields,
                                             PathModifyingPoint: path_modifying_points_input_fields,
                                             RequiredPoint: required_points_input_fields}
    toggle_frame_button_height = get_measurement(SCREEN_HEIGHT, 4)
    point_alterable_fields_frames_height = point_action_bar_top_edge - toggle_frame_button_height # The Point frames should go down to the top of the Point action bar

    # Commands Frame Dimensions
    commands_frame_length = get_measurement(SCREEN_LENGTH, 15)

    # Initial And End Conditions Frame
    initial_conditions_tab_length = SCREEN_LENGTH - toolbar_length - commands_frame_length
    initial_conditions_tab_left_edge = toolbar_length + commands_frame_length
    initial_angle_field = TitledInputField(WINDOW, SMALL_FONT, &#34;45&#34;, &#34;Initial Angle&#34;, title_field_background_color=blue, title_field_text_color=white)
    initial_speed_field = TitledInputField(WINDOW, SMALL_FONT, &#34;1&#34;, &#34;InitialSpeed&#34;, title_field_background_color=blue, title_field_text_color=white)
    path_is_closed_drop_down_menu = DropDownMenu(WINDOW, 0, [&#34;Path Is Closed&#34;, &#34;Path Is Open&#34;])
    end_angle_field = TitledInputField(WINDOW, SMALL_FONT, &#34;45&#34;, &#34;End Angle&#34;, title_field_background_color=blue, title_field_text_color=white)
    placement_angle_field = TitledInputField(WINDOW, SMALL_FONT, &#34;0&#34;, &#34;Placement Angle&#34;, title_field_background_color=blue, title_field_text_color=white)

    initial_and_end_condition_fields = [initial_angle_field, initial_speed_field, end_angle_field, placement_angle_field]

    # Field Image
    right_field_image = tkinter.PhotoImage(file=right_field_image_path)
    left_field_image = tkinter.PhotoImage(file=left_field_image_path)
    current_field_image = left_field_image
    field_image_bounds = [0, 0, SCREEN_LENGTH - point_bar_length, SCREEN_HEIGHT - toolbar_height]
    image_left_edge = FIELD_IMAGE_LENGTH / 2
    image_top_edge = FIELD_IMAGE_HEIGHT / 2
    field_canvas = None

    # States
    class States:
        DELETION = &#34;DELETION&#34;
        MOVING = &#34;MOVING&#34;
        ADD = &#34;ADD&#34;
        INIT = &#34;INIT&#34;

    point_editing_state = States.ADD
    point_editing_state_to_point_button = {States.DELETION: delete_button, States.MOVING: move_button, States.ADD: add_button}

    right_field_canvas = None
    left_field_canvas = None

    # Path Drawing
    path_line_width = 8
    path_modifying_point_line_width = 5

    # Storing information for saving files
    previous_file_name = &#34;&#34;
    previous_file_path = &#34;&#34;
    key_binding_to_function = {}
    event_key_binding_to_function = {}

    # Input Field Quick Transition Shortcuts
    currently_selected_point_number = 1
    current_input_field_number = 1

    copied_point = None

    def __init__(self):
        &#34;&#34;&#34;Used for setting up the entire GUI&#34;&#34;&#34;

        self.create_file_menu()

        WINDOW.bind(&#34;&lt;Button-1&gt;&#34;, lambda e: self.run_mouse_click(e))

        self.delete_button.configure(command=lambda: self.change_point_editing_state(self.States.DELETION, self.States.ADD))
        self.move_button.configure(command=lambda: self.change_point_editing_state(self.States.MOVING, self.States.INIT))
        self.add_button.configure(command=lambda: self.change_point_editing_state(self.States.ADD, self.States.DELETION))
        self.toggle_frame_button.configure(command=self.toggle_points_alterable_fields_frame)
        self.update_points_button.configure(command=self.update_points)
        self.draw_button.configure(command=self.draw_path)
        self.clear_field_button.configure(command=self.clear_field)
        self.reset_input_fields_button.configure(command=self.reset_all_point_input_fields)
        self.swap_points_button.configure(command=self.swap_points_function)
        self.save_file_button.configure(command=self.quick_save_file)

        commands_frame_saver.create_commands_frame(self.toolbar_length, self.toolbar_top_edge, self.commands_frame_length, self.toolbar_height)
        commands_main_frame.default_show_items()

        # Keyboard Shortcuts
        self.add_all_key_binding_shortcuts()
        self.set_button_colors()
        self.display_everything()

        self.initial_speed_field.error_message_function = DataValidator.get_float_error_message_function(-8, 8)
        self.initial_angle_field.error_message_function = DataValidator.get_float_error_message_function(0, 360)
        self.end_angle_field.error_message_function = DataValidator.get_float_error_message_function(0, 360)
        self.placement_angle_field.error_message_function = DataValidator.get_float_error_message_function(0, 360)

        points.set_points(self.path_modifying_points, self.path_action_points, self.required_points)

    def toggle_points_alterable_fields_frame(self, new_point_class=None):
        &#34;&#34;&#34;Toggles the PointsAlterableFieldsFrame, so it switches to being able to edit PathActionPoints and PathModifyingPoints&#34;&#34;&#34;

        self.run_error_checking()

        if not self.all_input_field_text_is_valid():
            return

        # Resetting the input field the GUI thinks is selected
        self.currently_selected_point_number = 1
        self.current_input_field_number = 1

        self.unselect_input_fields()

        last_frame = self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)
        last_frame.hide()

        self.current_points_altered_class = self.next_points_altered.get(self.current_points_altered_class)

        if new_point_class is not None:
            self.current_points_altered_class = new_point_class

        print(self.current_points_altered_class)
        new_frame = self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)
        new_frame.show()

        frame_name = self.points_altered_to_frame_name.get(self.current_points_altered_class)
        frame_button_color = self.points_altered_to_frame_button_color.get(self.current_points_altered_class)

        self.toggle_frame_button.configure(bg=frame_button_color, text=frame_name)

    def change_point_editing_state(self, point_editing_state, state_after_double_click):
        &#34;&#34;&#34;Changes the point editing state, so it can switch between adding, moving, deleting, and doing nothing with points&#34;&#34;&#34;

        # If the button is a toggle then it should toggle between INIT (doing nothing) and that point_editing_state
        if point_editing_state == self.point_editing_state:
            self.point_editing_state = state_after_double_click

        else:
            self.point_editing_state = point_editing_state

        self.set_button_colors()

    def create_file_menu(self):
        &#34;&#34;&#34;Creates the file menu system that allows the user to navigate between loading and saving files&#34;&#34;&#34;

        self.file_menu.add_command(label=&#34;Load File&#34;, command=self.request_load_file)
        self.file_menu.add_command(label=&#34;Save File As&#34;, command=self.save_file_as)
        self.file_menu.add_command(label=&#34;Right Field Image&#34;, command=lambda: self.draw_field_image(self.right_field_image))
        self.file_menu.add_command(label=&#34;Left Field Image&#34;, command=lambda: self.draw_field_image(self.left_field_image))
        WINDOW.configure(menu=self.menu)

    def create_bottom_bar(self):
        &#34;&#34;&#34;Creates the button bar at the bottom of the screen (updating points, draw button, etc.)&#34;&#34;&#34;

        grid = Grid([0, self.toolbar_top_edge, self.toolbar_length, self.toolbar_height], 1, None)
        grid.turn_into_grid([self.draw_button, self.update_points_button, self.save_file_button,
                             self.clear_field_button, self.reset_input_fields_button], None, None)

    def create_switch_points_bar(self):
        &#34;&#34;&#34;Creates the bar that allows you to switch points around&#34;&#34;&#34;

        grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.switching_points_bar_top_edge, self.point_bar_length, self.switching_points_bar_height], 1, None)
        grid.turn_into_grid([self.selected_point_field, self.switched_point_field, self.swap_points_button], None, None)

    def create_point_action_bar(self):
        &#34;&#34;&#34;Creates the bar that allows you to be able to add, delete, and move points&#34;&#34;&#34;

        grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.point_action_bar_top_edge, self.point_bar_length, self.point_action_bar_height], 1, None)
        grid.turn_into_grid([self.add_button, self.delete_button, self.move_button], None, None)

    def create_point_alterable_fields_frames(self):
        &#34;&#34;&#34;Creates the bar that allows you to be able to modify the field&#39;s attributes like X, Y, Command, etc.&#34;&#34;&#34;

        grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.toggle_frame_button_height, self.point_bar_length, self.point_alterable_fields_frames_height], None, 1)

        # So they have the same dimensions
        grid.turn_into_grid([self.path_modifying_point_alterable_fields_frame], None, None)
        grid.turn_into_grid([self.path_action_point_alterable_fields_frame], None, None)
        grid.turn_into_grid([self.required_point_alterable_fields_frame], None, None)

        self.path_action_point_alterable_fields_frame.hide()
        self.required_point_alterable_fields_frame.hide()
        self.path_modifying_point_alterable_fields_frame.show()

        self.toggle_frame_button.place(x=grid.left_edge, y=0, width=self.point_bar_length, height=self.toggle_frame_button_height)

        frame_name = self.points_altered_to_frame_name.get(self.current_points_altered_class)
        frame_button_color = self.points_altered_to_frame_button_color.get(self.current_points_altered_class)

        self.toggle_frame_button.configure(bg=frame_button_color, text=frame_name)

    def save_file_as(self):
        &#34;&#34;&#34;Saves a new file with the contents of the GUI&#34;&#34;&#34;

        self.run_error_checking()

        if len(self.path_modifying_points) &lt; 2:
            messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
            return

        if not self.all_input_field_text_is_valid():
            return

        file = filedialog.asksaveasfile(mode=&#39;w&#39;, defaultextension=&#34;.json&#34;)

        if file is not None:
            create_file(&#34;swerve_input.txt&#34;)
            create_file(&#34;swerve_output.txt&#34;)

            self.previous_file_name = get_file_name(file)
            self.previous_file_path = file.name

            self.save_file(get_file_name(file), file)


    def quick_save_file(self):
        &#34;&#34;&#34; Saves the file &#39;quickly.&#39; The user only has to hit Ctrl + s or hit the save file button and the previous file
            will be replaced with the new contents&#34;&#34;&#34;

        if self.previous_file_path is not None and self.previous_file_name != &#34;&#34;:
            file = open(self.previous_file_path, &#34;w&#34;)
            self.save_file(self.previous_file_name, file)

        else:
            messagebox.showerror(&#34;ERROR&#34;, &#34;No file has been previous selected. Either Load a File or Save a File as, so &#34;
                                          &#34;I know where to save the files&#34;)

    def save_file(self, file_name, file):
        &#34;&#34;&#34;Saves the file with the contents of the GUI&#34;&#34;&#34;

        create_file(&#34;swerve_input.txt&#34;)
        create_file(&#34;swerve_output.txt&#34;)

        self.run_error_checking()
        if self.all_input_field_text_is_valid():
            self._save_file(file_name, file)

    def _save_file(self, file_name, file):
        &#34;&#34;&#34;Saves the file with the contents of the GUI&#34;&#34;&#34;

        if len(self.path_modifying_points) &lt; 2:
            messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
            return

        start_all_json_contents = {
            &#34;Name&#34;: file_name,
            &#34;Closed&#34;: self.path_is_closed_drop_down_menu.get_selected_item() == &#34;Path Is Closed&#34;,
            &#34;ClosedValue&#34;: self.path_is_closed_drop_down_menu.get_selected_item(),
            &#34;InitialAngle&#34;: self.initial_angle_field.get_text(),
            &#34;EndAngle&#34;: self.end_angle_field.get_text(),
            &#34;InitialSpeed&#34;: self.initial_speed_field.get_text(),
            &#34;offsetAngle&#34;: self.placement_angle_field.get_text()
        }

        initial_path_action_point, first_required_point, last_required_point = self.get_path_action_points_to_reflect_conditions()
        path_action_points = copy_list(self.path_action_points)
        path_action_points.append(initial_path_action_point)

        json_file_writer.write_positions_to_file()

        if len(points.path_action_points) &lt;= 1:
            first_path_action_point_coordinates = get_closest_path_point(path_action_points[0].get_field_left_edge(),
                                                                         path_action_points[0].get_field_top_edge())

            left_edge, top_edge = json_file_writer.get_next_path_action_point_coordinates(first_path_action_point_coordinates)
            additional_path_action_point = PathActionPoint(None, None, False)

            additional_path_action_point.set_field_left_edge(left_edge)
            additional_path_action_point.set_field_top_edge(top_edge)
            additional_path_action_point.set_speed(path_action_points[0].get_speed())
            additional_path_action_point.set_command(&#34;none&#34;)
            additional_path_action_point.is_needed = False

            path_action_points.append(additional_path_action_point)


        placement_angle = float(self.placement_angle_field.get_text())
        json_file_writer.write_file(file, self.path_modifying_points,
                                    path_action_points, start_all_json_contents, first_required_point,
                                    last_required_point, placement_angle)

        first_required_point.destroy()
        last_required_point.destroy()
        initial_path_action_point.destroy()

        file.close()

    def get_path_action_points_to_reflect_conditions(self):
        &#34;&#34;&#34;
            Returns:
                list[MovablePoint]: {initial_path_action_point, first_required_point, last_required_point}; The updated control points
                that reflect what was entered in the conditions tab + the first and last required point&#34;&#34;&#34;

        last_path_modifying_point = self.path_modifying_points[len(self.path_modifying_points) - 1]
        # The first point on the path must have a path modifying point, so the robot has the information to start the path
        initial_required_point = self.get_required_point_at_path_modifying_point(self.path_modifying_points[0], float(self.initial_angle_field.get_text()), 0)
        last_required_point = self.get_required_point_at_path_modifying_point(last_path_modifying_point, float(self.end_angle_field.get_text()), len(points.path_modifying_points) - 1)

        initial_path_action_point: PathActionPoint = self.get_path_action_point_point_at_path_modifying_point(self.path_modifying_points[0], 0)

        additional_path_action_points = [initial_path_action_point, initial_required_point, last_required_point]

        for path_action_point in additional_path_action_points:
            path_action_point.is_needed = False

        return [initial_path_action_point, initial_required_point, last_required_point]

    def get_required_point_at_path_modifying_point(self, path_modifying_point, angle, path_modifying_point_path_index):
        &#34;&#34;&#34;
            Returns:
                PathActionPoint: a PathActionPoint that is at the same position of the &#39;path_modifying_point&#39; provided&#34;&#34;&#34;

        # None of these numbers matter because this PathActionPoint won&#39;t be on the screen
        required_point = RequiredPoint(None, 0, is_on_screen=False)

        required_point.set_field_left_edge(path_modifying_point.get_field_left_edge())
        required_point.set_field_top_edge(path_modifying_point.get_field_top_edge())
        required_point.set_angle(angle)
        required_point.set_t_value(path_modifying_point_path_index)

        return required_point

    def get_path_action_point_point_at_path_modifying_point(self, path_modifying_point, path_modifying_point_path_index):
        &#34;&#34;&#34;
            Returns:
                PathActionPoint: a PathActionPoint that is at the same position of the &#39;path_modifying_point&#39; provided&#34;&#34;&#34;

        # None of these numbers matter because this PathActionPoint won&#39;t be on the screen
        path_action_point = PathActionPoint(None, 0, is_on_screen=False)

        path_action_point.set_field_left_edge(path_modifying_point.get_field_left_edge())
        path_action_point.set_field_top_edge(path_modifying_point.get_field_top_edge())
        path_action_point.set_t_value(path_modifying_point_path_index)
        path_action_point.set_command(&#34;none&#34;)
        path_action_point.set_speed(float(self.initial_speed_field.get_text()))

        return path_action_point

    def display_everything(self):
        &#34;&#34;&#34;Allows the user to be able to interact with the GUI&#34;&#34;&#34;

        # Creating all the grids on the screen (the &#39;bars&#39;)
        self.create_bottom_bar()
        self.create_point_action_bar()
        self.create_point_alterable_fields_frames()
        self.create_switch_points_bar()
        self.create_initial_conditions_bar()

        # Creating the canvas that holds all the points and the field image
        canvas_length = SCREEN_LENGTH - self.point_bar_length
        canvas_height = SCREEN_HEIGHT - self.toolbar_height

        self.field_canvas = Canvas(master=WINDOW, width=canvas_length,
                                        height=canvas_height, bg=blue)

        self.draw_field_image()
        self.field_canvas.place(x=0, y=0)

    def draw_field_image(self, field_image=None):
        &#34;&#34;&#34;Displays the current field image&#34;&#34;&#34;

        if field_image is not None and field_image == self.right_field_image:
            important_variables.CENTER_OF_FIELD_HORIZONTAL_OFFSET = 0

        elif field_image is not None:
            important_variables.CENTER_OF_FIELD_HORIZONTAL_OFFSET = FIELD_IMAGE_LENGTH * PIXELS_TO_METERS_MULTIPLIER  # pixels -&gt; meters

        if field_image is not None and self.current_field_image != field_image:
            self.current_field_image = field_image

            for point in self.required_points + self.path_action_points + self.path_modifying_points:

                # Mirroring all the points along the y axis
                left_edge = point.get_field_left_edge() * -1
                point.set_field_left_edge(left_edge)

            for points_list in [self.path_modifying_points, self.path_action_points, self.required_points]:
                self.update_points(points_list)

        self.field_canvas.create_image(self.image_left_edge, self.image_top_edge, image=self.current_field_image)

    def create_initial_conditions_bar(self):
        &#34;&#34;&#34;Creates the bar for the conditions&#34;&#34;&#34;

        grid = Grid([self.initial_conditions_tab_left_edge, self.toolbar_top_edge, self.initial_conditions_tab_length, self.toolbar_height], 1, None)
        grid.turn_into_grid(self.initial_and_end_condition_fields + [self.path_is_closed_drop_down_menu], None, None)

    def create_point(self, mouse_left_edge, mouse_top_edge):
        &#34;&#34;&#34;Puts a new point onto the screen&#34;&#34;&#34;

        min_left_edge, min_top_edge, length, height = self.field_image_bounds
        max_left_edge = min_left_edge + length
        max_top_edge = min_top_edge + height

        is_within_horizontal_bounds = mouse_left_edge &gt;= min_left_edge and mouse_left_edge &lt;= max_left_edge
        is_within_vertical_bounds = mouse_top_edge &gt;= min_top_edge and mouse_top_edge &lt;= max_top_edge

        if is_within_horizontal_bounds and is_within_vertical_bounds:
            # Initializing the point
            point = self.current_points_altered_class(self.point_click_function, len(self.points_list) + 1)

            point_left_edge = mouse_left_edge - point.base_length / 2
            point_top_edge = mouse_top_edge - point.base_height / 2

            point.place(want_to_update_input_fields=True, x=point_left_edge, y=point_top_edge, width=point.base_length, height=point.base_height)

            self.points_list.append(point)
            point.set_order_position(len(self.points_list))
            self.add_needed_point_creation_information(point)
            self.point_alterable_fields_frame.update()
    def unselect_input_fields(self, selected_input_field=None):
        &#34;&#34;&#34;Makes all the points except the &#39;selected_input_field&#39; become unselected&#34;&#34;&#34;

        for input_field in self.points_input_fields:
            if selected_input_field is None:
                input_field.set_is_selected(False)

            # Meaning we can now check if the input_field is the same as the selected_input_field because the input_field
            # is not None
            elif input_field != selected_input_field:
                input_field.set_is_selected(False)

        for point in self.points_list:
            if selected_input_field is None:
                point.unselect()

            # Meaning we can now check if the input_field is the same as the selected_input_field because the input_field
            # is not None
            elif selected_input_field.belongs_to != point:
                point.unselect()

        self.selected_input_field = None

    def update_input_fields(self):
        &#34;&#34;&#34;So when a point is either added or deleted all the fields are recalculated to reflect the points&#34;&#34;&#34;

        # So there are no more input fields; then all the input fields can be populated
        # Creating a new variable, so the names don&#39;t conflict with the function name
        points_input_fields = self.points_input_fields
        points_input_fields[:] = []

        for point in self.points_list:
            points_input_fields += point.get_input_fields()

    def handle_input_field_click(self, selected_input_field, want_error_checking=True):
        &#34;&#34;&#34;Makes the input field become selected and the point that input field belongs to selected (all others are unselected)&#34;&#34;&#34;

        if want_error_checking:
            self.run_error_checking()

        selected_point = selected_input_field.belongs_to
        self.currently_selected_point_number = self.points_list.index(selected_point) + 1
        self.current_input_field_number = selected_point.get_input_fields().index(selected_input_field) + 1

        self.unselect_input_fields(selected_input_field)

        # Once all the input field&#39;s are unselected then make the &#39;selected_input_field&#39; selected
        selected_input_field.set_is_selected(True)
        selected_input_field.get_belongs_to().select()
        self.selected_input_field = selected_input_field

    # Click Functions
    def swap_points_function(self):
        &#34;&#34;&#34;Swaps the points&#34;&#34;&#34;

        # Indexes and the point numbers are of a difference of 1
        point_index = int(self.selected_point_field.get_text()) - 1
        new_index = int(self.switched_point_field.get_text()) - 1

        point_index_is_valid = point_index &gt;= 0 and point_index &lt; len(self.points_list)
        new_index_is_valid = new_index &gt;= 0 and new_index &lt; len(self.points_list)

        if point_index == new_index or not point_index_is_valid or not new_index_is_valid:
            messagebox.showerror(&#34;ERROR&#34;, f&#34;Can not swap points when invalid point order numbers are inputted. Values must be between 1 and {len(self.points_list)}&#34;)

        else:
            # Swaps the &#39;backend&#39; position of the points
            swap_list_items(self.points_list, point_index, new_index)
            self.point_alterable_fields_frame.update()

    def get_points_list(self, point):
        &#34;&#34;&#34;
            Returns:
                MovablePoint[]: the points list that the point belongs to (PathModifyingPoint, PathActionPoint, etc.)&#34;&#34;&#34;

        point_type = type(point)

        return self.points_altered_to_point_list.get(point_type)

    def get_index_of_point(self, point, points_list):
        &#34;&#34;&#34;
            Returns:
                int: the index of the point within the points list gotten from get_points_list()&#34;&#34;&#34;

        return points_list.index(point)

    def point_click_function(self, point):
        &#34;&#34;&#34; Runs different things depending on what point_editing_state the GUI is in when the point was clicked:
            ADD: Adds a point
            MOVING: Selects a point
            DELETION: Deletes a point
        &#34;&#34;&#34;

        points_list = self.get_points_list(point)
        index_of_point = self.get_index_of_point(point, points_list)

        if self.point_editing_state == self.States.DELETION:
            self.delete_point(index_of_point, points_list)

        if self.point_editing_state == self.States.MOVING:
            self.selected_point = point
            self.selected_point.select()

    def set_button_colors(self):
        &#34;&#34;&#34;Sets the colors of the add, move, delete buttons; called upon point_editing_state change&#34;&#34;&#34;

        for button in self.point_action_bar_buttons:
            button.configure(bg=pleasing_green)

        point_button = self.point_editing_state_to_point_button.get(self.point_editing_state)

        # If the point_editing_state is in INIT then there will be no point button causing an error
        if point_button is not None:
            point_button.configure(bg=dark_green)

    def run_mouse_click(self, event):
        &#34;&#34;&#34;Creates a point if the point_editing_state is ADD and moves a point if the point_editing_state is MOVE and a point is selected&#34;&#34;&#34;

        mouse_left_edge, mouse_top_edge = get_mouse_position()

        if self.point_editing_state == self.States.ADD:
            self.create_point(mouse_left_edge, mouse_top_edge)

        if self.point_editing_state == self.States.MOVING and self.selected_point is not None:
            self.selected_point.place(True, x=mouse_left_edge, y=mouse_top_edge)
            self.selected_point.unselect()
            self.selected_point = None

    def all_input_field_text_is_valid(self):
        &#34;&#34;&#34;
            Returns:
                bool: whether the text in the InputField&#39;s are valid&#34;&#34;&#34;

        if not WANT_ERROR_CHECKING:
            return True

        return self.get_error_message() is None

    def run_error_checking(self):
        &#34;&#34;&#34;Runs the error checking for all the input fields&#34;&#34;&#34;

        error_message = self.get_error_message()

        if error_message is not None and WANT_ERROR_CHECKING:
            messagebox.showerror(&#34;ERROR&#34;, error_message)

            # raise ValueError(&#34;There was bad input! Stopping the program&#34;)

    def get_error_message(self):
        &#34;&#34;&#34;
            Returns:
                str: the error message of the input field&#39;s if the data was invalid (None if it is valid)&#34;&#34;&#34;

        return_value = None

        for point in self.points_list:
            for input_field in point.get_input_fields():
                error_message = input_field.get_error_message()

                if error_message is not None:
                    return_value = error_message
                    input_field.get_error_message()
                    break

            if return_value is not None:
                break

        for input_field in self.initial_and_end_condition_fields:
            error_message = input_field.get_error_message()

            if error_message is not None and return_value is None:
                return_value = error_message
                break

        return return_value

    def update_points(self, points_list=None):
        &#34;&#34;&#34;Updates the points, so they reflect what the input field&#39;s have&#34;&#34;&#34;

        self.run_error_checking()

        if not self.all_input_field_text_is_valid():
            return

        if len(points.path_points) == 0:
            messagebox.showerror(&#34;ERROR&#34;, &#34;Make sure you have drawn the path before trying to update the points&#34;)
            return

        path_modifying_point_path_indexes = get_path_modifying_point_path_indexes()
        update_path_action_and_required_point_location(points.path_action_points, points.required_points,
                                                       path_modifying_point_path_indexes, points.path_modifying_points)

        points_list = self.points_list if points_list is None else points_list

        for point in points_list:
            point.default_update_coordinates()

    def reset_point_input_fields(self, points):
        &#34;&#34;&#34;Changes the input fields, so they reflect the points position on the screen&#34;&#34;&#34;

        for point in points:
            point.update_input_fields()

    def reset_all_point_input_fields(self):
        &#34;&#34;&#34;Changes all the point input fields, so they reflect the points position on the screen&#34;&#34;&#34;

        self.reset_point_input_fields(self.path_action_points)
        self.reset_point_input_fields(self.path_modifying_points)
        self.reset_point_input_fields(self.required_points)

        self.reset_point_input_fields(self.path_action_points)
        self.reset_point_input_fields(self.path_modifying_points)
        self.reset_point_input_fields(self.required_points)

    def clear_field(self):
        &#34;&#34;&#34;Clears the entire field of points and the path&#34;&#34;&#34;

        for point in self.path_action_points + self.path_modifying_points + self.required_points:
            point.destroy()

        # So they don&#39;t reassigned to a new spot in memory messing up the pointer the frames have to the lists
        self.path_action_points[:] = []
        self.path_modifying_points[:] = []
        self.required_points[:] = []

        self.field_canvas.delete(&#34;all&#34;)
        self.draw_field_image()

        # Updates the frames, so they contain the points data
        self.path_action_point_alterable_fields_frame.update()
        self.path_modifying_point_alterable_fields_frame.update()

    def change_point_order(self, is_up):
        &#34;&#34;&#34;Moves the order of the currently selected point (1 -&gt; 2)&#34;&#34;&#34;

        if self.selected_input_field is not None:
            point = self.selected_input_field.get_belongs_to()
            point_index, new_index = self.get_point_indexes(point, is_up)

            # Swaps the &#39;backend&#39; position of the points
            swap_list_items(self.points_list, point_index, new_index)
            self.point_alterable_fields_frame.update()

    def get_point_indexes(self, selected_point, is_up):
        &#34;&#34;&#34;
            Returns:
                 int: the new index of the point&#34;&#34;&#34;

        point_index = selected_point.get_order_position() - 1

        next_index = get_next_index(len(self.points_list) - 1, point_index)
        previous_index = get_previous_index(len(self.points_list) - 1, point_index)
        new_index = next_index if is_up else previous_index

        return [point_index, new_index]

    def draw_path(self):
        &#34;&#34;&#34;Writes the data to the file, which calls AutoFollower.jar then it draws the points from AutoFollower.jar&#34;&#34;&#34;

        self.run_error_checking()

        if len(self.path_modifying_points) &lt; 2:
            messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
            return

        if self.all_input_field_text_is_valid():
            create_file(&#34;swerve_input.txt&#34;)
            create_file(&#34;swerve_output.txt&#34;)

            # So all the lines are deleted and the image is still on the canvas
            self.field_canvas.delete(&#34;all&#34;)
            self.draw_field_image()
            json_file_writer.write_positions_to_file()
            self.update_point_information()

            draw_path_lines(self.field_canvas, self.path_modifying_point_line_width, self.path_line_width)
            self.draw_robot_angle_lines()

            self.update_points()

    def update_point_information(self):
        &#34;&#34;&#34;Updates all the point information, so drawing the path lines will work correctly&#34;&#34;&#34;

        unused, first_required_point, last_required_point = self.get_path_action_points_to_reflect_conditions()
        path_action_points = [first_required_point] + points.path_action_points + [last_required_point]
        required_points = [first_required_point] + self.required_points + [last_required_point]

        update_path_modifying_point_information(path_action_points=path_action_points, required_points=required_points)
        first_required_point.destroy()
        last_required_point.destroy()

    def draw_robot_angle_lines(self):
        &#34;&#34;&#34;Draws the robot angle at each control point&#34;&#34;&#34;

        for path_modifying_point in self.path_modifying_points:
            angle = path_modifying_point.get_angle_at_point()
            point2_left_edge = path_modifying_point.get_left_edge() + math.cos(angle) * ROBOT_ANGLE_LINE_LENGTH

            y_distance = math.sin(angle) * ROBOT_ANGLE_LINE_LENGTH
            point2_top_edge = path_modifying_point.get_top_edge() - y_distance

            self.field_canvas.create_line([path_modifying_point.get_left_edge(), path_modifying_point.get_top_edge()], [point2_left_edge, point2_top_edge],
                                          fill=ROBOT_ANGLE_LINE_COLOR, width=ROBOT_ANGLE_LINE_WIDTH)

    # Loading in from files
    def request_load_file(self):
        &#34;&#34;&#34;Loads a file onto the GUI&#34;&#34;&#34;

        file = filedialog.askopenfile(mode=&#39;r&#39;)

        if file is not None:
            self.load_file(file)

    def load_file(self, file):
        &#34;&#34;&#34;Loads the file onto the GUI&#34;&#34;&#34;

        json_contents = json.load(file)
        self.previous_file_path = file.name
        self.previous_file_name = get_file_name(file)

        file.close()

        # Setting the text field information to reflect the file
        self.placement_angle_field.set_text(json_contents[&#34;offsetAngle&#34;])
        self.initial_speed_field.set_text(json_contents[&#34;InitialSpeed&#34;])
        self.end_angle_field.set_text(json_contents[&#34;EndAngle&#34;])
        self.initial_angle_field.set_text(json_contents[&#34;InitialAngle&#34;])
        self.path_is_closed_drop_down_menu.set_selected_item(json_contents[&#34;ClosedValue&#34;])

        # Updating the points to reflect the file
        self.update_points_to_reflect_loaded_file(json_contents)
        self.add_needed_point_creation_information_for_all_points()

    def add_needed_point_creation_information_for_all_points(self):
        &#34;&#34;&#34; Adds all the information the other parts of the code need for a point to be created for all the points (
            for each point it calls add_needed_point_creation_information())&#34;&#34;&#34;

        for point in self.path_modifying_points + self.path_action_points:
            self.add_needed_point_creation_information(point)

        self.path_action_point_alterable_fields_frame.update()
        self.path_modifying_point_alterable_fields_frame.update()

    def add_needed_point_creation_information(self, point):
        &#34;&#34;&#34;Adds all the information the other parts of the code need for a point to be created&#34;&#34;&#34;

        point.set_input_fields_command(self.handle_input_field_click)
        self.update_input_fields()

    def update_points_to_reflect_loaded_file(self, json_contents):
        &#34;&#34;&#34;So the GUI reflects what is in the file (has to be delayed because it takes a while for the GUI to update and load the file)&#34;&#34;&#34;

        self.clear_field()

        json_file_loader.set_all_points_to_reflect_json_file(self.path_modifying_points, self.path_action_points,
                                                             self.required_points, json_contents, self.point_click_function)

        # So the points change location based on what is in the input fields
        self.update_points(self.path_action_points)
        self.update_points(self.path_modifying_points)
        self.update_points(self.required_points)

        # Otherwise the frame information does not update correctly
        self.toggle_points_alterable_fields_frame()
        self.toggle_points_alterable_fields_frame()
        self.toggle_points_alterable_fields_frame()

    def change_input_field_selection(self, event):
        &#34;&#34;&#34;Changes the selected input field depending on what key was pressed

            Args:
                event (str): the event name. Here are all the possible values:
                &#39;Up&#39; -&gt; Selects the next input field above the current one (belongs to the previous way point)
                &#39;Down&#39; -&gt; Selects the next input field below the current one (belongs to the next way point)
                &#39;Left&#39; -&gt; Selects the next input field to the right of the current one (belongs to the current way point)
                &#39;Right&#39; -&gt; Selects the previous input field to the left the current one (belongs to the current way point)
            
            
            Returns:
                None
        &#34;&#34;&#34;

        self.run_error_checking()

        if not self.all_input_field_text_is_valid():
            return

        if self.currently_selected_point_number &gt; len(self.points_list) or self.currently_selected_point_number &lt; 1:
            messagebox.showerror(&#34;ERROR&#34;, &#34;Cannot Switch input fields because they do not exist!!!&#34;)
            return

        valid_event_types = [&#34;Up&#34;, &#34;Down&#34;, &#34;Left&#34;, &#34;Right&#34;, &#34;Beginning&#34;, &#34;End&#34;]

        if not valid_event_types.__contains__(event):
            raise ValueError(&#34;Valid Data was not inputted!!!&#34;)

        user_modifiable_fields = self.get_user_modifiable_fields(self.currently_selected_point_number)
        # Modifying the numbers, so the selected input_field is not out of bounds of the input_fields on the screen
        max_input_field_number = len(user_modifiable_fields)

        if event == &#34;Up&#34;:
            self.currently_selected_point_number -= 1

        if event == &#34;Down&#34;:
            self.currently_selected_point_number += 1

        if event == &#34;Left&#34;:
            self.current_input_field_number -= 1

        if event == &#34;Right&#34;:
            self.current_input_field_number += 1

        if event == &#34;Beginning&#34;:
            self.current_input_field_number = 1

        if event == &#34;End&#34;:
            self.current_input_field_number = max_input_field_number

        if self.current_input_field_number &gt; max_input_field_number:
            self.current_input_field_number = 1
            self.currently_selected_point_number += 1

        if self.current_input_field_number &lt;= 0:
            self.current_input_field_number = max_input_field_number
            self.currently_selected_point_number -= 1

        self.make_input_field_selection_valid()
    def make_input_field_selection_valid(self):
        &#34;&#34;&#34;Makes sure where the GUI thinks the next input field selection is valid&#34;&#34;&#34;

        # Making sure the currently selected points are cyclic 0 -&gt; max_index -&gt; 0 -&gt; etc.
        max_selected_point_number = len(self.points_list)

        if self.currently_selected_point_number &gt; max_selected_point_number:
            self.currently_selected_point_number = 1

        if self.currently_selected_point_number &lt;= 0:
            self.currently_selected_point_number = max_selected_point_number

        self.focus_on_input_field(self.currently_selected_point_number, self.current_input_field_number)

    def add_all_key_binding_shortcuts(self):
        &#34;&#34;&#34;Adds all the key binding shortcuts to the Auto GUI&#34;&#34;&#34;

        key_binding_to_function = {}

        key_binding_to_function[&#34;&lt;Control-a&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(PathModifyingPoint)
        key_binding_to_function[&#34;&lt;Control-c&gt;&#34;] = lambda event: self.copy_point()
        key_binding_to_function[&#34;&lt;Control-d&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(RequiredPoint)
        key_binding_to_function[&#34;&lt;KeyPress-d&gt;&#34;] = lambda event: self.draw_path()
        key_binding_to_function[&#34;&lt;KeyPress-e&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.MOVING,
                                                                                  self.States.MOVING)
        key_binding_to_function[&#34;&lt;KeyPress-f&gt;&#34;] = lambda event: self.save_file_as()
        key_binding_to_function[&#34;&lt;KeyPress-g&gt;&#34;] = lambda event: self.request_load_file()

        key_binding_to_function[&#34;&lt;KeyPress-h&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Left&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-i&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Beginning&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-j&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Down&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-k&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Up&#34;)
        key_binding_to_function[&#34;&lt;Control-l&gt;&#34;] = lambda event: self.request_load_file()
        key_binding_to_function[&#34;&lt;KeyPress-l&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Right&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-o&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;End&#34;)
        key_binding_to_function[&#34;&lt;KeyPress-q&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.ADD,
                                                                                   self.States.ADD)
        key_binding_to_function[&#34;&lt;KeyPress-r&gt;&#34;] = lambda event: self.reset_all_point_input_fields()
        key_binding_to_function[&#34;&lt;KeyPress-s&gt;&#34;] = lambda event: self.quick_save_file()
        key_binding_to_function[&#34;&lt;Control-s&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(PathActionPoint)
        key_binding_to_function[&#34;&lt;Control-v&gt;&#34;] = lambda event: self.paste_point()
        key_binding_to_function[&#34;&lt;KeyPress-u&gt;&#34;] = lambda event: self.clear_field()
        key_binding_to_function[&#34;&lt;KeyPress-w&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.DELETION,
                                                                                               self.States.DELETION)
        key_binding_to_function[&#34;&lt;KeyPress-z&gt;&#34;] = lambda event: self.swap_points_function()

        key_binding_to_function[&#34;&lt;KeyPress-Return&gt;&#34;] = lambda event: self.update_points(self.points_list)
        key_binding_to_function[&#34;&lt;Control-space&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame()
        key_binding_to_function[&#34;&lt;Control-BackSpace&gt;&#34;] = lambda event: self.delete_point()
        key_binding_to_function[&#34;&lt;KeyPress-Up&gt;&#34;] = lambda event: self.change_point_order(False)
        key_binding_to_function[&#34;&lt;KeyPress-Down&gt;&#34;] = lambda event: self.change_point_order(True)

        key_binding_to_function[&#34;&lt;KeyPress-Tab&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Right&#34;)

        for key_binding in key_binding_to_function.keys():
            WINDOW.bind(key_binding, key_binding_to_function.get(key_binding))

            # Finding the event_key_binding because the event_key_binding has different information than the key_binding.
            # For instance, key_binding is &#39;&lt;KeyPress-u&gt;&#39; while event_key_binding is &#39;u&#39;
            first_dash_index = key_binding.index(&#34;-&#34;)
            event_key_binding = key_binding[first_dash_index + 1:]
            event_key_binding = event_key_binding[:-1] # The last character of the string is &#39;&gt;&#39; which is not needed

            important_variables.all_key_bindings.append(event_key_binding)

    def focus_on_input_field(self, point_number, input_field_number):
        &#34;&#34;&#34;Moves the mouse to the input field and the desired location&#34;&#34;&#34;

        user_modifiable_field = self.get_user_modifiable_fields(point_number)[input_field_number - 1]

        user_modifiable_field.focus_force()
        self.handle_input_field_click(user_modifiable_field, want_error_checking=False)

    def get_user_modifiable_fields(self, point_number):
        &#34;&#34;&#34;
            Returns:
                list[object] the fields the user can modify for that point number (in the PointAlterableFieldsFrame)&#34;&#34;&#34;

        point_index = point_number - 1
        point: MovablePoint = self.points_list[point_index]

        user_modifiable_fields = point.get_input_fields()

        return user_modifiable_fields

    def copy_point(self):
        &#34;&#34;&#34;Copies the currently selected point into the &#39;clipboard&#39;&#34;&#34;&#34;

        point_index = self.currently_selected_point_number - 1
        self.copied_point = self.points_list[point_index]

    def paste_point(self):
        &#34;&#34;&#34;Pastes the copied_point into the GUI&#34;&#34;&#34;

        new_point = self.current_points_altered_class(self.point_click_function,
                                                      self.currently_selected_point_number + 1)

        if self.copied_point is not None:
            # Making the input fields alike
            copied_point_input_fields = self.copied_point.get_input_fields()
            new_point_input_fields = new_point.get_input_fields()

            for x in range(len(copied_point_input_fields)):
                copied_point_input_field = copied_point_input_fields[x]
                new_point_input_field = new_point_input_fields[x]

                new_point_input_field.set_text(copied_point_input_field.get_text())

        # Update the GUI
        self.points_list.insert(self.currently_selected_point_number, new_point)
        self.add_needed_point_creation_information(new_point)
        self.point_alterable_fields_frame.update()
        self.change_input_field_selection(&#34;Down&#34;)
        new_point.place(True, x=self.copied_point.get_left_edge(), y=self.copied_point.get_top_edge())

    def delete_point(self, index_of_point=None, points_list=None):
        &#34;&#34;&#34;Deletes the currently selected point&#34;&#34;&#34;

        deletion_is_valid = True

        if index_of_point is None:
            index_of_point = self.currently_selected_point_number - 1

            # It is possible to hit the keyboard shortcut and not be able to delete validly
            index_is_valid = index_of_point &gt;= 0 and index_of_point &lt; len(self.points_list) and len(self.points_list) &gt;= 0

            deletion_is_valid = index_is_valid and self.selected_input_field is not None

        if points_list is None:
            points_list = self.points_list

        if deletion_is_valid:
            point = points_list[index_of_point]
            del points_list[index_of_point]
            self.path_action_point_alterable_fields_frame.update()
            self.path_modifying_point_alterable_fields_frame.update()
            self.required_point_alterable_fields_frame.update()
            point.destroy()

            self.update_input_fields()

        # Makes sure we have a input field selected
        if deletion_is_valid and len(self.points_list) &gt;= 1:
            self.make_input_field_selection_valid()

    @property
    def points_list(self):
        &#34;&#34;&#34;The current points being modified that belong to the PointAlterableFieldsFrame&#34;&#34;&#34;
        
        return self.points_altered_to_point_list.get(self.current_points_altered_class)

    @property
    def point_alterable_fields_frame(self):
        &#34;&#34;&#34;The current PointAlterableFieldsFrame that is on the screen&#34;&#34;&#34;
        
        return self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)

    @property
    def points_input_fields(self):
        &#34;&#34;&#34;The points input fields that are currently on the screen that belong to the PointAlterableFieldsFrame&#34;&#34;&#34;
        
        return self.points_altered_to_points_input_fields.get(self.current_points_altered_class)

    @property
    def current_point_list(self):
        &#34;&#34;&#34;The points list that is currently in use&#34;&#34;&#34;
        
        # First number in Point states signifies if it is the path modifying points list being modified
        return self.points_altered_to_point_list.get(self.current_points_altered_class)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Auto-GUI.main_screen.MainScreen.States"><code class="name">var <span class="ident">States</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.add_button"><code class="name">var <span class="ident">add_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.clear_field_button"><code class="name">var <span class="ident">clear_field_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.commands_frame_length"><code class="name">var <span class="ident">commands_frame_length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.copied_point"><code class="name">var <span class="ident">copied_point</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.current_field_image"><code class="name">var <span class="ident">current_field_image</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.current_input_field_number"><code class="name">var <span class="ident">current_input_field_number</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.current_points_altered_class"><code class="name">var <span class="ident">current_points_altered_class</span></code></dt>
<dd>
<div class="desc"><p>The points that dictate the path of the robot</p></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.currently_selected_point_number"><code class="name">var <span class="ident">currently_selected_point_number</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.delete_button"><code class="name">var <span class="ident">delete_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.draw_button"><code class="name">var <span class="ident">draw_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.end_angle_field"><code class="name">var <span class="ident">end_angle_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.event_key_binding_to_function"><code class="name">var <span class="ident">event_key_binding_to_function</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.field_canvas"><code class="name">var <span class="ident">field_canvas</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.field_image_bounds"><code class="name">var <span class="ident">field_image_bounds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.file_menu"><code class="name">var <span class="ident">file_menu</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.file_name"><code class="name">var <span class="ident">file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.font_size"><code class="name">var <span class="ident">font_size</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.image_left_edge"><code class="name">var <span class="ident">image_left_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.image_top_edge"><code class="name">var <span class="ident">image_top_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.initial_and_end_condition_fields"><code class="name">var <span class="ident">initial_and_end_condition_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.initial_angle_field"><code class="name">var <span class="ident">initial_angle_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.initial_conditions_tab_left_edge"><code class="name">var <span class="ident">initial_conditions_tab_left_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.initial_conditions_tab_length"><code class="name">var <span class="ident">initial_conditions_tab_length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.initial_speed_field"><code class="name">var <span class="ident">initial_speed_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.key_binding_to_function"><code class="name">var <span class="ident">key_binding_to_function</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.left_field_canvas"><code class="name">var <span class="ident">left_field_canvas</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.left_field_image"><code class="name">var <span class="ident">left_field_image</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.menu"><code class="name">var <span class="ident">menu</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.move_button"><code class="name">var <span class="ident">move_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.next_points_altered"><code class="name">var <span class="ident">next_points_altered</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_action_point_alterable_fields_frame"><code class="name">var <span class="ident">path_action_point_alterable_fields_frame</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_action_points"><code class="name">var <span class="ident">path_action_points</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_action_points_input_fields"><code class="name">var <span class="ident">path_action_points_input_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_is_closed_drop_down_menu"><code class="name">var <span class="ident">path_is_closed_drop_down_menu</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_line_width"><code class="name">var <span class="ident">path_line_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_modifying_point_alterable_fields_frame"><code class="name">var <span class="ident">path_modifying_point_alterable_fields_frame</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_modifying_point_line_width"><code class="name">var <span class="ident">path_modifying_point_line_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_modifying_points"><code class="name">var <span class="ident">path_modifying_points</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.path_modifying_points_input_fields"><code class="name">var <span class="ident">path_modifying_points_input_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.placement_angle_field"><code class="name">var <span class="ident">placement_angle_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_action_bar_buttons"><code class="name">var <span class="ident">point_action_bar_buttons</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_action_bar_height"><code class="name">var <span class="ident">point_action_bar_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_action_bar_top_edge"><code class="name">var <span class="ident">point_action_bar_top_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_alterable_fields_frames_height"><code class="name">var <span class="ident">point_alterable_fields_frames_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_bar_length"><code class="name">var <span class="ident">point_bar_length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_editing_state"><code class="name">var <span class="ident">point_editing_state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_editing_state_to_point_button"><code class="name">var <span class="ident">point_editing_state_to_point_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_altered_to_frame_button_color"><code class="name">var <span class="ident">points_altered_to_frame_button_color</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_altered_to_frame_name"><code class="name">var <span class="ident">points_altered_to_frame_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_altered_to_point_alterable_fields_frame"><code class="name">var <span class="ident">points_altered_to_point_alterable_fields_frame</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_altered_to_point_list"><code class="name">var <span class="ident">points_altered_to_point_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_altered_to_points_input_fields"><code class="name">var <span class="ident">points_altered_to_points_input_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.popup_windows"><code class="name">var <span class="ident">popup_windows</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.previous_file_name"><code class="name">var <span class="ident">previous_file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.previous_file_path"><code class="name">var <span class="ident">previous_file_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.required_point_alterable_fields_frame"><code class="name">var <span class="ident">required_point_alterable_fields_frame</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.required_points"><code class="name">var <span class="ident">required_points</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.required_points_input_fields"><code class="name">var <span class="ident">required_points_input_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.reset_input_fields_button"><code class="name">var <span class="ident">reset_input_fields_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.right_field_canvas"><code class="name">var <span class="ident">right_field_canvas</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.right_field_image"><code class="name">var <span class="ident">right_field_image</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.save_file_button"><code class="name">var <span class="ident">save_file_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.selected_input_field"><code class="name">var <span class="ident">selected_input_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.selected_point"><code class="name">var <span class="ident">selected_point</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.selected_point_field"><code class="name">var <span class="ident">selected_point_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.swap_points_button"><code class="name">var <span class="ident">swap_points_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.switched_point_field"><code class="name">var <span class="ident">switched_point_field</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.switching_points_bar_height"><code class="name">var <span class="ident">switching_points_bar_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.switching_points_bar_top_edge"><code class="name">var <span class="ident">switching_points_bar_top_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.toggle_frame_button"><code class="name">var <span class="ident">toggle_frame_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.toggle_frame_button_height"><code class="name">var <span class="ident">toggle_frame_button_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.toolbar_height"><code class="name">var <span class="ident">toolbar_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.toolbar_length"><code class="name">var <span class="ident">toolbar_length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.toolbar_top_edge"><code class="name">var <span class="ident">toolbar_top_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.update_points_button"><code class="name">var <span class="ident">update_points_button</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Auto-GUI.main_screen.MainScreen.current_point_list"><code class="name">var <span class="ident">current_point_list</span></code></dt>
<dd>
<div class="desc"><p>The points list that is currently in use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_point_list(self):
    &#34;&#34;&#34;The points list that is currently in use&#34;&#34;&#34;
    
    # First number in Point states signifies if it is the path modifying points list being modified
    return self.points_altered_to_point_list.get(self.current_points_altered_class)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_alterable_fields_frame"><code class="name">var <span class="ident">point_alterable_fields_frame</span></code></dt>
<dd>
<div class="desc"><p>The current PointAlterableFieldsFrame that is on the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def point_alterable_fields_frame(self):
    &#34;&#34;&#34;The current PointAlterableFieldsFrame that is on the screen&#34;&#34;&#34;
    
    return self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_input_fields"><code class="name">var <span class="ident">points_input_fields</span></code></dt>
<dd>
<div class="desc"><p>The points input fields that are currently on the screen that belong to the PointAlterableFieldsFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points_input_fields(self):
    &#34;&#34;&#34;The points input fields that are currently on the screen that belong to the PointAlterableFieldsFrame&#34;&#34;&#34;
    
    return self.points_altered_to_points_input_fields.get(self.current_points_altered_class)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.points_list"><code class="name">var <span class="ident">points_list</span></code></dt>
<dd>
<div class="desc"><p>The current points being modified that belong to the PointAlterableFieldsFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points_list(self):
    &#34;&#34;&#34;The current points being modified that belong to the PointAlterableFieldsFrame&#34;&#34;&#34;
    
    return self.points_altered_to_point_list.get(self.current_points_altered_class)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Auto-GUI.main_screen.MainScreen.add_all_key_binding_shortcuts"><code class="name flex">
<span>def <span class="ident">add_all_key_binding_shortcuts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds all the key binding shortcuts to the Auto GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_all_key_binding_shortcuts(self):
    &#34;&#34;&#34;Adds all the key binding shortcuts to the Auto GUI&#34;&#34;&#34;

    key_binding_to_function = {}

    key_binding_to_function[&#34;&lt;Control-a&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(PathModifyingPoint)
    key_binding_to_function[&#34;&lt;Control-c&gt;&#34;] = lambda event: self.copy_point()
    key_binding_to_function[&#34;&lt;Control-d&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(RequiredPoint)
    key_binding_to_function[&#34;&lt;KeyPress-d&gt;&#34;] = lambda event: self.draw_path()
    key_binding_to_function[&#34;&lt;KeyPress-e&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.MOVING,
                                                                              self.States.MOVING)
    key_binding_to_function[&#34;&lt;KeyPress-f&gt;&#34;] = lambda event: self.save_file_as()
    key_binding_to_function[&#34;&lt;KeyPress-g&gt;&#34;] = lambda event: self.request_load_file()

    key_binding_to_function[&#34;&lt;KeyPress-h&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Left&#34;)
    key_binding_to_function[&#34;&lt;KeyPress-i&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Beginning&#34;)
    key_binding_to_function[&#34;&lt;KeyPress-j&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Down&#34;)
    key_binding_to_function[&#34;&lt;KeyPress-k&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Up&#34;)
    key_binding_to_function[&#34;&lt;Control-l&gt;&#34;] = lambda event: self.request_load_file()
    key_binding_to_function[&#34;&lt;KeyPress-l&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Right&#34;)
    key_binding_to_function[&#34;&lt;KeyPress-o&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;End&#34;)
    key_binding_to_function[&#34;&lt;KeyPress-q&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.ADD,
                                                                               self.States.ADD)
    key_binding_to_function[&#34;&lt;KeyPress-r&gt;&#34;] = lambda event: self.reset_all_point_input_fields()
    key_binding_to_function[&#34;&lt;KeyPress-s&gt;&#34;] = lambda event: self.quick_save_file()
    key_binding_to_function[&#34;&lt;Control-s&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame(PathActionPoint)
    key_binding_to_function[&#34;&lt;Control-v&gt;&#34;] = lambda event: self.paste_point()
    key_binding_to_function[&#34;&lt;KeyPress-u&gt;&#34;] = lambda event: self.clear_field()
    key_binding_to_function[&#34;&lt;KeyPress-w&gt;&#34;] = lambda event: self.change_point_editing_state(self.States.DELETION,
                                                                                           self.States.DELETION)
    key_binding_to_function[&#34;&lt;KeyPress-z&gt;&#34;] = lambda event: self.swap_points_function()

    key_binding_to_function[&#34;&lt;KeyPress-Return&gt;&#34;] = lambda event: self.update_points(self.points_list)
    key_binding_to_function[&#34;&lt;Control-space&gt;&#34;] = lambda event: self.toggle_points_alterable_fields_frame()
    key_binding_to_function[&#34;&lt;Control-BackSpace&gt;&#34;] = lambda event: self.delete_point()
    key_binding_to_function[&#34;&lt;KeyPress-Up&gt;&#34;] = lambda event: self.change_point_order(False)
    key_binding_to_function[&#34;&lt;KeyPress-Down&gt;&#34;] = lambda event: self.change_point_order(True)

    key_binding_to_function[&#34;&lt;KeyPress-Tab&gt;&#34;] = lambda event: self.change_input_field_selection(&#34;Right&#34;)

    for key_binding in key_binding_to_function.keys():
        WINDOW.bind(key_binding, key_binding_to_function.get(key_binding))

        # Finding the event_key_binding because the event_key_binding has different information than the key_binding.
        # For instance, key_binding is &#39;&lt;KeyPress-u&gt;&#39; while event_key_binding is &#39;u&#39;
        first_dash_index = key_binding.index(&#34;-&#34;)
        event_key_binding = key_binding[first_dash_index + 1:]
        event_key_binding = event_key_binding[:-1] # The last character of the string is &#39;&gt;&#39; which is not needed

        important_variables.all_key_bindings.append(event_key_binding)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.add_needed_point_creation_information"><code class="name flex">
<span>def <span class="ident">add_needed_point_creation_information</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds all the information the other parts of the code need for a point to be created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_needed_point_creation_information(self, point):
    &#34;&#34;&#34;Adds all the information the other parts of the code need for a point to be created&#34;&#34;&#34;

    point.set_input_fields_command(self.handle_input_field_click)
    self.update_input_fields()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.add_needed_point_creation_information_for_all_points"><code class="name flex">
<span>def <span class="ident">add_needed_point_creation_information_for_all_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds all the information the other parts of the code need for a point to be created for all the points (
for each point it calls add_needed_point_creation_information())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_needed_point_creation_information_for_all_points(self):
    &#34;&#34;&#34; Adds all the information the other parts of the code need for a point to be created for all the points (
        for each point it calls add_needed_point_creation_information())&#34;&#34;&#34;

    for point in self.path_modifying_points + self.path_action_points:
        self.add_needed_point_creation_information(point)

    self.path_action_point_alterable_fields_frame.update()
    self.path_modifying_point_alterable_fields_frame.update()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.all_input_field_text_is_valid"><code class="name flex">
<span>def <span class="ident">all_input_field_text_is_valid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether the text in the InputField's are valid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_input_field_text_is_valid(self):
    &#34;&#34;&#34;
        Returns:
            bool: whether the text in the InputField&#39;s are valid&#34;&#34;&#34;

    if not WANT_ERROR_CHECKING:
        return True

    return self.get_error_message() is None</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.change_input_field_selection"><code class="name flex">
<span>def <span class="ident">change_input_field_selection</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the selected input field depending on what key was pressed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>the event name. Here are all the possible values:</dd>
</dl>
<p>'Up' -&gt; Selects the next input field above the current one (belongs to the previous way point)
'Down' -&gt; Selects the next input field below the current one (belongs to the next way point)
'Left' -&gt; Selects the next input field to the right of the current one (belongs to the current way point)
'Right' -&gt; Selects the previous input field to the left the current one (belongs to the current way point)</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_input_field_selection(self, event):
    &#34;&#34;&#34;Changes the selected input field depending on what key was pressed

        Args:
            event (str): the event name. Here are all the possible values:
            &#39;Up&#39; -&gt; Selects the next input field above the current one (belongs to the previous way point)
            &#39;Down&#39; -&gt; Selects the next input field below the current one (belongs to the next way point)
            &#39;Left&#39; -&gt; Selects the next input field to the right of the current one (belongs to the current way point)
            &#39;Right&#39; -&gt; Selects the previous input field to the left the current one (belongs to the current way point)
        
        
        Returns:
            None
    &#34;&#34;&#34;

    self.run_error_checking()

    if not self.all_input_field_text_is_valid():
        return

    if self.currently_selected_point_number &gt; len(self.points_list) or self.currently_selected_point_number &lt; 1:
        messagebox.showerror(&#34;ERROR&#34;, &#34;Cannot Switch input fields because they do not exist!!!&#34;)
        return

    valid_event_types = [&#34;Up&#34;, &#34;Down&#34;, &#34;Left&#34;, &#34;Right&#34;, &#34;Beginning&#34;, &#34;End&#34;]

    if not valid_event_types.__contains__(event):
        raise ValueError(&#34;Valid Data was not inputted!!!&#34;)

    user_modifiable_fields = self.get_user_modifiable_fields(self.currently_selected_point_number)
    # Modifying the numbers, so the selected input_field is not out of bounds of the input_fields on the screen
    max_input_field_number = len(user_modifiable_fields)

    if event == &#34;Up&#34;:
        self.currently_selected_point_number -= 1

    if event == &#34;Down&#34;:
        self.currently_selected_point_number += 1

    if event == &#34;Left&#34;:
        self.current_input_field_number -= 1

    if event == &#34;Right&#34;:
        self.current_input_field_number += 1

    if event == &#34;Beginning&#34;:
        self.current_input_field_number = 1

    if event == &#34;End&#34;:
        self.current_input_field_number = max_input_field_number

    if self.current_input_field_number &gt; max_input_field_number:
        self.current_input_field_number = 1
        self.currently_selected_point_number += 1

    if self.current_input_field_number &lt;= 0:
        self.current_input_field_number = max_input_field_number
        self.currently_selected_point_number -= 1

    self.make_input_field_selection_valid()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.change_point_editing_state"><code class="name flex">
<span>def <span class="ident">change_point_editing_state</span></span>(<span>self, point_editing_state, state_after_double_click)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the point editing state, so it can switch between adding, moving, deleting, and doing nothing with points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_point_editing_state(self, point_editing_state, state_after_double_click):
    &#34;&#34;&#34;Changes the point editing state, so it can switch between adding, moving, deleting, and doing nothing with points&#34;&#34;&#34;

    # If the button is a toggle then it should toggle between INIT (doing nothing) and that point_editing_state
    if point_editing_state == self.point_editing_state:
        self.point_editing_state = state_after_double_click

    else:
        self.point_editing_state = point_editing_state

    self.set_button_colors()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.change_point_order"><code class="name flex">
<span>def <span class="ident">change_point_order</span></span>(<span>self, is_up)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the order of the currently selected point (1 -&gt; 2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_point_order(self, is_up):
    &#34;&#34;&#34;Moves the order of the currently selected point (1 -&gt; 2)&#34;&#34;&#34;

    if self.selected_input_field is not None:
        point = self.selected_input_field.get_belongs_to()
        point_index, new_index = self.get_point_indexes(point, is_up)

        # Swaps the &#39;backend&#39; position of the points
        swap_list_items(self.points_list, point_index, new_index)
        self.point_alterable_fields_frame.update()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.clear_field"><code class="name flex">
<span>def <span class="ident">clear_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the entire field of points and the path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_field(self):
    &#34;&#34;&#34;Clears the entire field of points and the path&#34;&#34;&#34;

    for point in self.path_action_points + self.path_modifying_points + self.required_points:
        point.destroy()

    # So they don&#39;t reassigned to a new spot in memory messing up the pointer the frames have to the lists
    self.path_action_points[:] = []
    self.path_modifying_points[:] = []
    self.required_points[:] = []

    self.field_canvas.delete(&#34;all&#34;)
    self.draw_field_image()

    # Updates the frames, so they contain the points data
    self.path_action_point_alterable_fields_frame.update()
    self.path_modifying_point_alterable_fields_frame.update()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.copy_point"><code class="name flex">
<span>def <span class="ident">copy_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the currently selected point into the 'clipboard'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_point(self):
    &#34;&#34;&#34;Copies the currently selected point into the &#39;clipboard&#39;&#34;&#34;&#34;

    point_index = self.currently_selected_point_number - 1
    self.copied_point = self.points_list[point_index]</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_bottom_bar"><code class="name flex">
<span>def <span class="ident">create_bottom_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the button bar at the bottom of the screen (updating points, draw button, etc.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_bottom_bar(self):
    &#34;&#34;&#34;Creates the button bar at the bottom of the screen (updating points, draw button, etc.)&#34;&#34;&#34;

    grid = Grid([0, self.toolbar_top_edge, self.toolbar_length, self.toolbar_height], 1, None)
    grid.turn_into_grid([self.draw_button, self.update_points_button, self.save_file_button,
                         self.clear_field_button, self.reset_input_fields_button], None, None)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_file_menu"><code class="name flex">
<span>def <span class="ident">create_file_menu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the file menu system that allows the user to navigate between loading and saving files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_file_menu(self):
    &#34;&#34;&#34;Creates the file menu system that allows the user to navigate between loading and saving files&#34;&#34;&#34;

    self.file_menu.add_command(label=&#34;Load File&#34;, command=self.request_load_file)
    self.file_menu.add_command(label=&#34;Save File As&#34;, command=self.save_file_as)
    self.file_menu.add_command(label=&#34;Right Field Image&#34;, command=lambda: self.draw_field_image(self.right_field_image))
    self.file_menu.add_command(label=&#34;Left Field Image&#34;, command=lambda: self.draw_field_image(self.left_field_image))
    WINDOW.configure(menu=self.menu)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_initial_conditions_bar"><code class="name flex">
<span>def <span class="ident">create_initial_conditions_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the bar for the conditions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_initial_conditions_bar(self):
    &#34;&#34;&#34;Creates the bar for the conditions&#34;&#34;&#34;

    grid = Grid([self.initial_conditions_tab_left_edge, self.toolbar_top_edge, self.initial_conditions_tab_length, self.toolbar_height], 1, None)
    grid.turn_into_grid(self.initial_and_end_condition_fields + [self.path_is_closed_drop_down_menu], None, None)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_point"><code class="name flex">
<span>def <span class="ident">create_point</span></span>(<span>self, mouse_left_edge, mouse_top_edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts a new point onto the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_point(self, mouse_left_edge, mouse_top_edge):
    &#34;&#34;&#34;Puts a new point onto the screen&#34;&#34;&#34;

    min_left_edge, min_top_edge, length, height = self.field_image_bounds
    max_left_edge = min_left_edge + length
    max_top_edge = min_top_edge + height

    is_within_horizontal_bounds = mouse_left_edge &gt;= min_left_edge and mouse_left_edge &lt;= max_left_edge
    is_within_vertical_bounds = mouse_top_edge &gt;= min_top_edge and mouse_top_edge &lt;= max_top_edge

    if is_within_horizontal_bounds and is_within_vertical_bounds:
        # Initializing the point
        point = self.current_points_altered_class(self.point_click_function, len(self.points_list) + 1)

        point_left_edge = mouse_left_edge - point.base_length / 2
        point_top_edge = mouse_top_edge - point.base_height / 2

        point.place(want_to_update_input_fields=True, x=point_left_edge, y=point_top_edge, width=point.base_length, height=point.base_height)

        self.points_list.append(point)
        point.set_order_position(len(self.points_list))
        self.add_needed_point_creation_information(point)
        self.point_alterable_fields_frame.update()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_point_action_bar"><code class="name flex">
<span>def <span class="ident">create_point_action_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the bar that allows you to be able to add, delete, and move points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_point_action_bar(self):
    &#34;&#34;&#34;Creates the bar that allows you to be able to add, delete, and move points&#34;&#34;&#34;

    grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.point_action_bar_top_edge, self.point_bar_length, self.point_action_bar_height], 1, None)
    grid.turn_into_grid([self.add_button, self.delete_button, self.move_button], None, None)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_point_alterable_fields_frames"><code class="name flex">
<span>def <span class="ident">create_point_alterable_fields_frames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the bar that allows you to be able to modify the field's attributes like X, Y, Command, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_point_alterable_fields_frames(self):
    &#34;&#34;&#34;Creates the bar that allows you to be able to modify the field&#39;s attributes like X, Y, Command, etc.&#34;&#34;&#34;

    grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.toggle_frame_button_height, self.point_bar_length, self.point_alterable_fields_frames_height], None, 1)

    # So they have the same dimensions
    grid.turn_into_grid([self.path_modifying_point_alterable_fields_frame], None, None)
    grid.turn_into_grid([self.path_action_point_alterable_fields_frame], None, None)
    grid.turn_into_grid([self.required_point_alterable_fields_frame], None, None)

    self.path_action_point_alterable_fields_frame.hide()
    self.required_point_alterable_fields_frame.hide()
    self.path_modifying_point_alterable_fields_frame.show()

    self.toggle_frame_button.place(x=grid.left_edge, y=0, width=self.point_bar_length, height=self.toggle_frame_button_height)

    frame_name = self.points_altered_to_frame_name.get(self.current_points_altered_class)
    frame_button_color = self.points_altered_to_frame_button_color.get(self.current_points_altered_class)

    self.toggle_frame_button.configure(bg=frame_button_color, text=frame_name)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.create_switch_points_bar"><code class="name flex">
<span>def <span class="ident">create_switch_points_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the bar that allows you to switch points around</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_switch_points_bar(self):
    &#34;&#34;&#34;Creates the bar that allows you to switch points around&#34;&#34;&#34;

    grid = Grid([SCREEN_LENGTH - self.point_bar_length, self.switching_points_bar_top_edge, self.point_bar_length, self.switching_points_bar_height], 1, None)
    grid.turn_into_grid([self.selected_point_field, self.switched_point_field, self.swap_points_button], None, None)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.delete_point"><code class="name flex">
<span>def <span class="ident">delete_point</span></span>(<span>self, index_of_point=None, points_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the currently selected point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_point(self, index_of_point=None, points_list=None):
    &#34;&#34;&#34;Deletes the currently selected point&#34;&#34;&#34;

    deletion_is_valid = True

    if index_of_point is None:
        index_of_point = self.currently_selected_point_number - 1

        # It is possible to hit the keyboard shortcut and not be able to delete validly
        index_is_valid = index_of_point &gt;= 0 and index_of_point &lt; len(self.points_list) and len(self.points_list) &gt;= 0

        deletion_is_valid = index_is_valid and self.selected_input_field is not None

    if points_list is None:
        points_list = self.points_list

    if deletion_is_valid:
        point = points_list[index_of_point]
        del points_list[index_of_point]
        self.path_action_point_alterable_fields_frame.update()
        self.path_modifying_point_alterable_fields_frame.update()
        self.required_point_alterable_fields_frame.update()
        point.destroy()

        self.update_input_fields()

    # Makes sure we have a input field selected
    if deletion_is_valid and len(self.points_list) &gt;= 1:
        self.make_input_field_selection_valid()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.display_everything"><code class="name flex">
<span>def <span class="ident">display_everything</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the user to be able to interact with the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_everything(self):
    &#34;&#34;&#34;Allows the user to be able to interact with the GUI&#34;&#34;&#34;

    # Creating all the grids on the screen (the &#39;bars&#39;)
    self.create_bottom_bar()
    self.create_point_action_bar()
    self.create_point_alterable_fields_frames()
    self.create_switch_points_bar()
    self.create_initial_conditions_bar()

    # Creating the canvas that holds all the points and the field image
    canvas_length = SCREEN_LENGTH - self.point_bar_length
    canvas_height = SCREEN_HEIGHT - self.toolbar_height

    self.field_canvas = Canvas(master=WINDOW, width=canvas_length,
                                    height=canvas_height, bg=blue)

    self.draw_field_image()
    self.field_canvas.place(x=0, y=0)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.draw_field_image"><code class="name flex">
<span>def <span class="ident">draw_field_image</span></span>(<span>self, field_image=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the current field image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_field_image(self, field_image=None):
    &#34;&#34;&#34;Displays the current field image&#34;&#34;&#34;

    if field_image is not None and field_image == self.right_field_image:
        important_variables.CENTER_OF_FIELD_HORIZONTAL_OFFSET = 0

    elif field_image is not None:
        important_variables.CENTER_OF_FIELD_HORIZONTAL_OFFSET = FIELD_IMAGE_LENGTH * PIXELS_TO_METERS_MULTIPLIER  # pixels -&gt; meters

    if field_image is not None and self.current_field_image != field_image:
        self.current_field_image = field_image

        for point in self.required_points + self.path_action_points + self.path_modifying_points:

            # Mirroring all the points along the y axis
            left_edge = point.get_field_left_edge() * -1
            point.set_field_left_edge(left_edge)

        for points_list in [self.path_modifying_points, self.path_action_points, self.required_points]:
            self.update_points(points_list)

    self.field_canvas.create_image(self.image_left_edge, self.image_top_edge, image=self.current_field_image)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.draw_path"><code class="name flex">
<span>def <span class="ident">draw_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the data to the file, which calls AutoFollower.jar then it draws the points from AutoFollower.jar</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_path(self):
    &#34;&#34;&#34;Writes the data to the file, which calls AutoFollower.jar then it draws the points from AutoFollower.jar&#34;&#34;&#34;

    self.run_error_checking()

    if len(self.path_modifying_points) &lt; 2:
        messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
        return

    if self.all_input_field_text_is_valid():
        create_file(&#34;swerve_input.txt&#34;)
        create_file(&#34;swerve_output.txt&#34;)

        # So all the lines are deleted and the image is still on the canvas
        self.field_canvas.delete(&#34;all&#34;)
        self.draw_field_image()
        json_file_writer.write_positions_to_file()
        self.update_point_information()

        draw_path_lines(self.field_canvas, self.path_modifying_point_line_width, self.path_line_width)
        self.draw_robot_angle_lines()

        self.update_points()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.draw_robot_angle_lines"><code class="name flex">
<span>def <span class="ident">draw_robot_angle_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the robot angle at each control point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_robot_angle_lines(self):
    &#34;&#34;&#34;Draws the robot angle at each control point&#34;&#34;&#34;

    for path_modifying_point in self.path_modifying_points:
        angle = path_modifying_point.get_angle_at_point()
        point2_left_edge = path_modifying_point.get_left_edge() + math.cos(angle) * ROBOT_ANGLE_LINE_LENGTH

        y_distance = math.sin(angle) * ROBOT_ANGLE_LINE_LENGTH
        point2_top_edge = path_modifying_point.get_top_edge() - y_distance

        self.field_canvas.create_line([path_modifying_point.get_left_edge(), path_modifying_point.get_top_edge()], [point2_left_edge, point2_top_edge],
                                      fill=ROBOT_ANGLE_LINE_COLOR, width=ROBOT_ANGLE_LINE_WIDTH)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.focus_on_input_field"><code class="name flex">
<span>def <span class="ident">focus_on_input_field</span></span>(<span>self, point_number, input_field_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the mouse to the input field and the desired location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_on_input_field(self, point_number, input_field_number):
    &#34;&#34;&#34;Moves the mouse to the input field and the desired location&#34;&#34;&#34;

    user_modifiable_field = self.get_user_modifiable_fields(point_number)[input_field_number - 1]

    user_modifiable_field.focus_force()
    self.handle_input_field_click(user_modifiable_field, want_error_checking=False)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_error_message"><code class="name flex">
<span>def <span class="ident">get_error_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the error message of the input field's if the data was invalid (None if it is valid)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error_message(self):
    &#34;&#34;&#34;
        Returns:
            str: the error message of the input field&#39;s if the data was invalid (None if it is valid)&#34;&#34;&#34;

    return_value = None

    for point in self.points_list:
        for input_field in point.get_input_fields():
            error_message = input_field.get_error_message()

            if error_message is not None:
                return_value = error_message
                input_field.get_error_message()
                break

        if return_value is not None:
            break

    for input_field in self.initial_and_end_condition_fields:
        error_message = input_field.get_error_message()

        if error_message is not None and return_value is None:
            return_value = error_message
            break

    return return_value</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_index_of_point"><code class="name flex">
<span>def <span class="ident">get_index_of_point</span></span>(<span>self, point, points_list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the index of the point within the points list gotten from get_points_list()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index_of_point(self, point, points_list):
    &#34;&#34;&#34;
        Returns:
            int: the index of the point within the points list gotten from get_points_list()&#34;&#34;&#34;

    return points_list.index(point)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_path_action_point_point_at_path_modifying_point"><code class="name flex">
<span>def <span class="ident">get_path_action_point_point_at_path_modifying_point</span></span>(<span>self, path_modifying_point, path_modifying_point_path_index)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>PathActionPoint</code></dt>
<dd>a PathActionPoint that is at the same position of the 'path_modifying_point' provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_action_point_point_at_path_modifying_point(self, path_modifying_point, path_modifying_point_path_index):
    &#34;&#34;&#34;
        Returns:
            PathActionPoint: a PathActionPoint that is at the same position of the &#39;path_modifying_point&#39; provided&#34;&#34;&#34;

    # None of these numbers matter because this PathActionPoint won&#39;t be on the screen
    path_action_point = PathActionPoint(None, 0, is_on_screen=False)

    path_action_point.set_field_left_edge(path_modifying_point.get_field_left_edge())
    path_action_point.set_field_top_edge(path_modifying_point.get_field_top_edge())
    path_action_point.set_t_value(path_modifying_point_path_index)
    path_action_point.set_command(&#34;none&#34;)
    path_action_point.set_speed(float(self.initial_speed_field.get_text()))

    return path_action_point</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_path_action_points_to_reflect_conditions"><code class="name flex">
<span>def <span class="ident">get_path_action_points_to_reflect_conditions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list[MovablePoint]</code></dt>
<dd>{initial_path_action_point, first_required_point, last_required_point}; The updated control points</dd>
</dl>
<p>that reflect what was entered in the conditions tab + the first and last required point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_action_points_to_reflect_conditions(self):
    &#34;&#34;&#34;
        Returns:
            list[MovablePoint]: {initial_path_action_point, first_required_point, last_required_point}; The updated control points
            that reflect what was entered in the conditions tab + the first and last required point&#34;&#34;&#34;

    last_path_modifying_point = self.path_modifying_points[len(self.path_modifying_points) - 1]
    # The first point on the path must have a path modifying point, so the robot has the information to start the path
    initial_required_point = self.get_required_point_at_path_modifying_point(self.path_modifying_points[0], float(self.initial_angle_field.get_text()), 0)
    last_required_point = self.get_required_point_at_path_modifying_point(last_path_modifying_point, float(self.end_angle_field.get_text()), len(points.path_modifying_points) - 1)

    initial_path_action_point: PathActionPoint = self.get_path_action_point_point_at_path_modifying_point(self.path_modifying_points[0], 0)

    additional_path_action_points = [initial_path_action_point, initial_required_point, last_required_point]

    for path_action_point in additional_path_action_points:
        path_action_point.is_needed = False

    return [initial_path_action_point, initial_required_point, last_required_point]</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_point_indexes"><code class="name flex">
<span>def <span class="ident">get_point_indexes</span></span>(<span>self, selected_point, is_up)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the new index of the point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_point_indexes(self, selected_point, is_up):
    &#34;&#34;&#34;
        Returns:
             int: the new index of the point&#34;&#34;&#34;

    point_index = selected_point.get_order_position() - 1

    next_index = get_next_index(len(self.points_list) - 1, point_index)
    previous_index = get_previous_index(len(self.points_list) - 1, point_index)
    new_index = next_index if is_up else previous_index

    return [point_index, new_index]</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_points_list"><code class="name flex">
<span>def <span class="ident">get_points_list</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>MovablePoint[]</code></dt>
<dd>the points list that the point belongs to (PathModifyingPoint, PathActionPoint, etc.)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points_list(self, point):
    &#34;&#34;&#34;
        Returns:
            MovablePoint[]: the points list that the point belongs to (PathModifyingPoint, PathActionPoint, etc.)&#34;&#34;&#34;

    point_type = type(point)

    return self.points_altered_to_point_list.get(point_type)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_required_point_at_path_modifying_point"><code class="name flex">
<span>def <span class="ident">get_required_point_at_path_modifying_point</span></span>(<span>self, path_modifying_point, angle, path_modifying_point_path_index)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>PathActionPoint</code></dt>
<dd>a PathActionPoint that is at the same position of the 'path_modifying_point' provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_point_at_path_modifying_point(self, path_modifying_point, angle, path_modifying_point_path_index):
    &#34;&#34;&#34;
        Returns:
            PathActionPoint: a PathActionPoint that is at the same position of the &#39;path_modifying_point&#39; provided&#34;&#34;&#34;

    # None of these numbers matter because this PathActionPoint won&#39;t be on the screen
    required_point = RequiredPoint(None, 0, is_on_screen=False)

    required_point.set_field_left_edge(path_modifying_point.get_field_left_edge())
    required_point.set_field_top_edge(path_modifying_point.get_field_top_edge())
    required_point.set_angle(angle)
    required_point.set_t_value(path_modifying_point_path_index)

    return required_point</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.get_user_modifiable_fields"><code class="name flex">
<span>def <span class="ident">get_user_modifiable_fields</span></span>(<span>self, point_number)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>list[object] the fields the user can modify for that point number (in the PointAlterableFieldsFrame)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_modifiable_fields(self, point_number):
    &#34;&#34;&#34;
        Returns:
            list[object] the fields the user can modify for that point number (in the PointAlterableFieldsFrame)&#34;&#34;&#34;

    point_index = point_number - 1
    point: MovablePoint = self.points_list[point_index]

    user_modifiable_fields = point.get_input_fields()

    return user_modifiable_fields</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.handle_input_field_click"><code class="name flex">
<span>def <span class="ident">handle_input_field_click</span></span>(<span>self, selected_input_field, want_error_checking=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the input field become selected and the point that input field belongs to selected (all others are unselected)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_input_field_click(self, selected_input_field, want_error_checking=True):
    &#34;&#34;&#34;Makes the input field become selected and the point that input field belongs to selected (all others are unselected)&#34;&#34;&#34;

    if want_error_checking:
        self.run_error_checking()

    selected_point = selected_input_field.belongs_to
    self.currently_selected_point_number = self.points_list.index(selected_point) + 1
    self.current_input_field_number = selected_point.get_input_fields().index(selected_input_field) + 1

    self.unselect_input_fields(selected_input_field)

    # Once all the input field&#39;s are unselected then make the &#39;selected_input_field&#39; selected
    selected_input_field.set_is_selected(True)
    selected_input_field.get_belongs_to().select()
    self.selected_input_field = selected_input_field</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.load_file"><code class="name flex">
<span>def <span class="ident">load_file</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the file onto the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_file(self, file):
    &#34;&#34;&#34;Loads the file onto the GUI&#34;&#34;&#34;

    json_contents = json.load(file)
    self.previous_file_path = file.name
    self.previous_file_name = get_file_name(file)

    file.close()

    # Setting the text field information to reflect the file
    self.placement_angle_field.set_text(json_contents[&#34;offsetAngle&#34;])
    self.initial_speed_field.set_text(json_contents[&#34;InitialSpeed&#34;])
    self.end_angle_field.set_text(json_contents[&#34;EndAngle&#34;])
    self.initial_angle_field.set_text(json_contents[&#34;InitialAngle&#34;])
    self.path_is_closed_drop_down_menu.set_selected_item(json_contents[&#34;ClosedValue&#34;])

    # Updating the points to reflect the file
    self.update_points_to_reflect_loaded_file(json_contents)
    self.add_needed_point_creation_information_for_all_points()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.make_input_field_selection_valid"><code class="name flex">
<span>def <span class="ident">make_input_field_selection_valid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes sure where the GUI thinks the next input field selection is valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_input_field_selection_valid(self):
    &#34;&#34;&#34;Makes sure where the GUI thinks the next input field selection is valid&#34;&#34;&#34;

    # Making sure the currently selected points are cyclic 0 -&gt; max_index -&gt; 0 -&gt; etc.
    max_selected_point_number = len(self.points_list)

    if self.currently_selected_point_number &gt; max_selected_point_number:
        self.currently_selected_point_number = 1

    if self.currently_selected_point_number &lt;= 0:
        self.currently_selected_point_number = max_selected_point_number

    self.focus_on_input_field(self.currently_selected_point_number, self.current_input_field_number)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.paste_point"><code class="name flex">
<span>def <span class="ident">paste_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pastes the copied_point into the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paste_point(self):
    &#34;&#34;&#34;Pastes the copied_point into the GUI&#34;&#34;&#34;

    new_point = self.current_points_altered_class(self.point_click_function,
                                                  self.currently_selected_point_number + 1)

    if self.copied_point is not None:
        # Making the input fields alike
        copied_point_input_fields = self.copied_point.get_input_fields()
        new_point_input_fields = new_point.get_input_fields()

        for x in range(len(copied_point_input_fields)):
            copied_point_input_field = copied_point_input_fields[x]
            new_point_input_field = new_point_input_fields[x]

            new_point_input_field.set_text(copied_point_input_field.get_text())

    # Update the GUI
    self.points_list.insert(self.currently_selected_point_number, new_point)
    self.add_needed_point_creation_information(new_point)
    self.point_alterable_fields_frame.update()
    self.change_input_field_selection(&#34;Down&#34;)
    new_point.place(True, x=self.copied_point.get_left_edge(), y=self.copied_point.get_top_edge())</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.point_click_function"><code class="name flex">
<span>def <span class="ident">point_click_function</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs different things depending on what point_editing_state the GUI is in when the point was clicked:
ADD: Adds a point
MOVING: Selects a point
DELETION: Deletes a point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_click_function(self, point):
    &#34;&#34;&#34; Runs different things depending on what point_editing_state the GUI is in when the point was clicked:
        ADD: Adds a point
        MOVING: Selects a point
        DELETION: Deletes a point
    &#34;&#34;&#34;

    points_list = self.get_points_list(point)
    index_of_point = self.get_index_of_point(point, points_list)

    if self.point_editing_state == self.States.DELETION:
        self.delete_point(index_of_point, points_list)

    if self.point_editing_state == self.States.MOVING:
        self.selected_point = point
        self.selected_point.select()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.quick_save_file"><code class="name flex">
<span>def <span class="ident">quick_save_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the file 'quickly.' The user only has to hit Ctrl + s or hit the save file button and the previous file
will be replaced with the new contents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quick_save_file(self):
    &#34;&#34;&#34; Saves the file &#39;quickly.&#39; The user only has to hit Ctrl + s or hit the save file button and the previous file
        will be replaced with the new contents&#34;&#34;&#34;

    if self.previous_file_path is not None and self.previous_file_name != &#34;&#34;:
        file = open(self.previous_file_path, &#34;w&#34;)
        self.save_file(self.previous_file_name, file)

    else:
        messagebox.showerror(&#34;ERROR&#34;, &#34;No file has been previous selected. Either Load a File or Save a File as, so &#34;
                                      &#34;I know where to save the files&#34;)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.request_load_file"><code class="name flex">
<span>def <span class="ident">request_load_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a file onto the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_load_file(self):
    &#34;&#34;&#34;Loads a file onto the GUI&#34;&#34;&#34;

    file = filedialog.askopenfile(mode=&#39;r&#39;)

    if file is not None:
        self.load_file(file)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.reset_all_point_input_fields"><code class="name flex">
<span>def <span class="ident">reset_all_point_input_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes all the point input fields, so they reflect the points position on the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_all_point_input_fields(self):
    &#34;&#34;&#34;Changes all the point input fields, so they reflect the points position on the screen&#34;&#34;&#34;

    self.reset_point_input_fields(self.path_action_points)
    self.reset_point_input_fields(self.path_modifying_points)
    self.reset_point_input_fields(self.required_points)

    self.reset_point_input_fields(self.path_action_points)
    self.reset_point_input_fields(self.path_modifying_points)
    self.reset_point_input_fields(self.required_points)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.reset_point_input_fields"><code class="name flex">
<span>def <span class="ident">reset_point_input_fields</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the input fields, so they reflect the points position on the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_point_input_fields(self, points):
    &#34;&#34;&#34;Changes the input fields, so they reflect the points position on the screen&#34;&#34;&#34;

    for point in points:
        point.update_input_fields()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.run_error_checking"><code class="name flex">
<span>def <span class="ident">run_error_checking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the error checking for all the input fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_error_checking(self):
    &#34;&#34;&#34;Runs the error checking for all the input fields&#34;&#34;&#34;

    error_message = self.get_error_message()

    if error_message is not None and WANT_ERROR_CHECKING:
        messagebox.showerror(&#34;ERROR&#34;, error_message)

        # raise ValueError(&#34;There was bad input! Stopping the program&#34;)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.run_mouse_click"><code class="name flex">
<span>def <span class="ident">run_mouse_click</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a point if the point_editing_state is ADD and moves a point if the point_editing_state is MOVE and a point is selected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_mouse_click(self, event):
    &#34;&#34;&#34;Creates a point if the point_editing_state is ADD and moves a point if the point_editing_state is MOVE and a point is selected&#34;&#34;&#34;

    mouse_left_edge, mouse_top_edge = get_mouse_position()

    if self.point_editing_state == self.States.ADD:
        self.create_point(mouse_left_edge, mouse_top_edge)

    if self.point_editing_state == self.States.MOVING and self.selected_point is not None:
        self.selected_point.place(True, x=mouse_left_edge, y=mouse_top_edge)
        self.selected_point.unselect()
        self.selected_point = None</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.save_file"><code class="name flex">
<span>def <span class="ident">save_file</span></span>(<span>self, file_name, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the file with the contents of the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_file(self, file_name, file):
    &#34;&#34;&#34;Saves the file with the contents of the GUI&#34;&#34;&#34;

    create_file(&#34;swerve_input.txt&#34;)
    create_file(&#34;swerve_output.txt&#34;)

    self.run_error_checking()
    if self.all_input_field_text_is_valid():
        self._save_file(file_name, file)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.save_file_as"><code class="name flex">
<span>def <span class="ident">save_file_as</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a new file with the contents of the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_file_as(self):
    &#34;&#34;&#34;Saves a new file with the contents of the GUI&#34;&#34;&#34;

    self.run_error_checking()

    if len(self.path_modifying_points) &lt; 2:
        messagebox.showerror(&#34;ERROR&#34;, &#34;There must be at least 2 path modifying points&#34;)
        return

    if not self.all_input_field_text_is_valid():
        return

    file = filedialog.asksaveasfile(mode=&#39;w&#39;, defaultextension=&#34;.json&#34;)

    if file is not None:
        create_file(&#34;swerve_input.txt&#34;)
        create_file(&#34;swerve_output.txt&#34;)

        self.previous_file_name = get_file_name(file)
        self.previous_file_path = file.name

        self.save_file(get_file_name(file), file)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.set_button_colors"><code class="name flex">
<span>def <span class="ident">set_button_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the colors of the add, move, delete buttons; called upon point_editing_state change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_button_colors(self):
    &#34;&#34;&#34;Sets the colors of the add, move, delete buttons; called upon point_editing_state change&#34;&#34;&#34;

    for button in self.point_action_bar_buttons:
        button.configure(bg=pleasing_green)

    point_button = self.point_editing_state_to_point_button.get(self.point_editing_state)

    # If the point_editing_state is in INIT then there will be no point button causing an error
    if point_button is not None:
        point_button.configure(bg=dark_green)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.swap_points_function"><code class="name flex">
<span>def <span class="ident">swap_points_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Swaps the points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_points_function(self):
    &#34;&#34;&#34;Swaps the points&#34;&#34;&#34;

    # Indexes and the point numbers are of a difference of 1
    point_index = int(self.selected_point_field.get_text()) - 1
    new_index = int(self.switched_point_field.get_text()) - 1

    point_index_is_valid = point_index &gt;= 0 and point_index &lt; len(self.points_list)
    new_index_is_valid = new_index &gt;= 0 and new_index &lt; len(self.points_list)

    if point_index == new_index or not point_index_is_valid or not new_index_is_valid:
        messagebox.showerror(&#34;ERROR&#34;, f&#34;Can not swap points when invalid point order numbers are inputted. Values must be between 1 and {len(self.points_list)}&#34;)

    else:
        # Swaps the &#39;backend&#39; position of the points
        swap_list_items(self.points_list, point_index, new_index)
        self.point_alterable_fields_frame.update()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.toggle_points_alterable_fields_frame"><code class="name flex">
<span>def <span class="ident">toggle_points_alterable_fields_frame</span></span>(<span>self, new_point_class=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles the PointsAlterableFieldsFrame, so it switches to being able to edit PathActionPoints and PathModifyingPoints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_points_alterable_fields_frame(self, new_point_class=None):
    &#34;&#34;&#34;Toggles the PointsAlterableFieldsFrame, so it switches to being able to edit PathActionPoints and PathModifyingPoints&#34;&#34;&#34;

    self.run_error_checking()

    if not self.all_input_field_text_is_valid():
        return

    # Resetting the input field the GUI thinks is selected
    self.currently_selected_point_number = 1
    self.current_input_field_number = 1

    self.unselect_input_fields()

    last_frame = self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)
    last_frame.hide()

    self.current_points_altered_class = self.next_points_altered.get(self.current_points_altered_class)

    if new_point_class is not None:
        self.current_points_altered_class = new_point_class

    print(self.current_points_altered_class)
    new_frame = self.points_altered_to_point_alterable_fields_frame.get(self.current_points_altered_class)
    new_frame.show()

    frame_name = self.points_altered_to_frame_name.get(self.current_points_altered_class)
    frame_button_color = self.points_altered_to_frame_button_color.get(self.current_points_altered_class)

    self.toggle_frame_button.configure(bg=frame_button_color, text=frame_name)</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.unselect_input_fields"><code class="name flex">
<span>def <span class="ident">unselect_input_fields</span></span>(<span>self, selected_input_field=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes all the points except the 'selected_input_field' become unselected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unselect_input_fields(self, selected_input_field=None):
    &#34;&#34;&#34;Makes all the points except the &#39;selected_input_field&#39; become unselected&#34;&#34;&#34;

    for input_field in self.points_input_fields:
        if selected_input_field is None:
            input_field.set_is_selected(False)

        # Meaning we can now check if the input_field is the same as the selected_input_field because the input_field
        # is not None
        elif input_field != selected_input_field:
            input_field.set_is_selected(False)

    for point in self.points_list:
        if selected_input_field is None:
            point.unselect()

        # Meaning we can now check if the input_field is the same as the selected_input_field because the input_field
        # is not None
        elif selected_input_field.belongs_to != point:
            point.unselect()

    self.selected_input_field = None</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.update_input_fields"><code class="name flex">
<span>def <span class="ident">update_input_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>So when a point is either added or deleted all the fields are recalculated to reflect the points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_input_fields(self):
    &#34;&#34;&#34;So when a point is either added or deleted all the fields are recalculated to reflect the points&#34;&#34;&#34;

    # So there are no more input fields; then all the input fields can be populated
    # Creating a new variable, so the names don&#39;t conflict with the function name
    points_input_fields = self.points_input_fields
    points_input_fields[:] = []

    for point in self.points_list:
        points_input_fields += point.get_input_fields()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.update_point_information"><code class="name flex">
<span>def <span class="ident">update_point_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates all the point information, so drawing the path lines will work correctly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_point_information(self):
    &#34;&#34;&#34;Updates all the point information, so drawing the path lines will work correctly&#34;&#34;&#34;

    unused, first_required_point, last_required_point = self.get_path_action_points_to_reflect_conditions()
    path_action_points = [first_required_point] + points.path_action_points + [last_required_point]
    required_points = [first_required_point] + self.required_points + [last_required_point]

    update_path_modifying_point_information(path_action_points=path_action_points, required_points=required_points)
    first_required_point.destroy()
    last_required_point.destroy()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.update_points"><code class="name flex">
<span>def <span class="ident">update_points</span></span>(<span>self, points_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the points, so they reflect what the input field's have</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_points(self, points_list=None):
    &#34;&#34;&#34;Updates the points, so they reflect what the input field&#39;s have&#34;&#34;&#34;

    self.run_error_checking()

    if not self.all_input_field_text_is_valid():
        return

    if len(points.path_points) == 0:
        messagebox.showerror(&#34;ERROR&#34;, &#34;Make sure you have drawn the path before trying to update the points&#34;)
        return

    path_modifying_point_path_indexes = get_path_modifying_point_path_indexes()
    update_path_action_and_required_point_location(points.path_action_points, points.required_points,
                                                   path_modifying_point_path_indexes, points.path_modifying_points)

    points_list = self.points_list if points_list is None else points_list

    for point in points_list:
        point.default_update_coordinates()</code></pre>
</details>
</dd>
<dt id="Auto-GUI.main_screen.MainScreen.update_points_to_reflect_loaded_file"><code class="name flex">
<span>def <span class="ident">update_points_to_reflect_loaded_file</span></span>(<span>self, json_contents)</span>
</code></dt>
<dd>
<div class="desc"><p>So the GUI reflects what is in the file (has to be delayed because it takes a while for the GUI to update and load the file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_points_to_reflect_loaded_file(self, json_contents):
    &#34;&#34;&#34;So the GUI reflects what is in the file (has to be delayed because it takes a while for the GUI to update and load the file)&#34;&#34;&#34;

    self.clear_field()

    json_file_loader.set_all_points_to_reflect_json_file(self.path_modifying_points, self.path_action_points,
                                                         self.required_points, json_contents, self.point_click_function)

    # So the points change location based on what is in the input fields
    self.update_points(self.path_action_points)
    self.update_points(self.path_modifying_points)
    self.update_points(self.required_points)

    # Otherwise the frame information does not update correctly
    self.toggle_points_alterable_fields_frame()
    self.toggle_points_alterable_fields_frame()
    self.toggle_points_alterable_fields_frame()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Auto-GUI" href="index.html">Auto-GUI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Auto-GUI.main_screen.MainScreen" href="#Auto-GUI.main_screen.MainScreen">MainScreen</a></code></h4>
<ul class="">
<li><code><a title="Auto-GUI.main_screen.MainScreen.States" href="#Auto-GUI.main_screen.MainScreen.States">States</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.add_all_key_binding_shortcuts" href="#Auto-GUI.main_screen.MainScreen.add_all_key_binding_shortcuts">add_all_key_binding_shortcuts</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.add_button" href="#Auto-GUI.main_screen.MainScreen.add_button">add_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.add_needed_point_creation_information" href="#Auto-GUI.main_screen.MainScreen.add_needed_point_creation_information">add_needed_point_creation_information</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.add_needed_point_creation_information_for_all_points" href="#Auto-GUI.main_screen.MainScreen.add_needed_point_creation_information_for_all_points">add_needed_point_creation_information_for_all_points</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.all_input_field_text_is_valid" href="#Auto-GUI.main_screen.MainScreen.all_input_field_text_is_valid">all_input_field_text_is_valid</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.change_input_field_selection" href="#Auto-GUI.main_screen.MainScreen.change_input_field_selection">change_input_field_selection</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.change_point_editing_state" href="#Auto-GUI.main_screen.MainScreen.change_point_editing_state">change_point_editing_state</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.change_point_order" href="#Auto-GUI.main_screen.MainScreen.change_point_order">change_point_order</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.clear_field" href="#Auto-GUI.main_screen.MainScreen.clear_field">clear_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.clear_field_button" href="#Auto-GUI.main_screen.MainScreen.clear_field_button">clear_field_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.commands_frame_length" href="#Auto-GUI.main_screen.MainScreen.commands_frame_length">commands_frame_length</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.copied_point" href="#Auto-GUI.main_screen.MainScreen.copied_point">copied_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.copy_point" href="#Auto-GUI.main_screen.MainScreen.copy_point">copy_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_bottom_bar" href="#Auto-GUI.main_screen.MainScreen.create_bottom_bar">create_bottom_bar</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_file_menu" href="#Auto-GUI.main_screen.MainScreen.create_file_menu">create_file_menu</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_initial_conditions_bar" href="#Auto-GUI.main_screen.MainScreen.create_initial_conditions_bar">create_initial_conditions_bar</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_point" href="#Auto-GUI.main_screen.MainScreen.create_point">create_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_point_action_bar" href="#Auto-GUI.main_screen.MainScreen.create_point_action_bar">create_point_action_bar</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_point_alterable_fields_frames" href="#Auto-GUI.main_screen.MainScreen.create_point_alterable_fields_frames">create_point_alterable_fields_frames</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.create_switch_points_bar" href="#Auto-GUI.main_screen.MainScreen.create_switch_points_bar">create_switch_points_bar</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.current_field_image" href="#Auto-GUI.main_screen.MainScreen.current_field_image">current_field_image</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.current_input_field_number" href="#Auto-GUI.main_screen.MainScreen.current_input_field_number">current_input_field_number</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.current_point_list" href="#Auto-GUI.main_screen.MainScreen.current_point_list">current_point_list</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.current_points_altered_class" href="#Auto-GUI.main_screen.MainScreen.current_points_altered_class">current_points_altered_class</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.currently_selected_point_number" href="#Auto-GUI.main_screen.MainScreen.currently_selected_point_number">currently_selected_point_number</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.delete_button" href="#Auto-GUI.main_screen.MainScreen.delete_button">delete_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.delete_point" href="#Auto-GUI.main_screen.MainScreen.delete_point">delete_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.display_everything" href="#Auto-GUI.main_screen.MainScreen.display_everything">display_everything</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.draw_button" href="#Auto-GUI.main_screen.MainScreen.draw_button">draw_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.draw_field_image" href="#Auto-GUI.main_screen.MainScreen.draw_field_image">draw_field_image</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.draw_path" href="#Auto-GUI.main_screen.MainScreen.draw_path">draw_path</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.draw_robot_angle_lines" href="#Auto-GUI.main_screen.MainScreen.draw_robot_angle_lines">draw_robot_angle_lines</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.end_angle_field" href="#Auto-GUI.main_screen.MainScreen.end_angle_field">end_angle_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.event_key_binding_to_function" href="#Auto-GUI.main_screen.MainScreen.event_key_binding_to_function">event_key_binding_to_function</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.field_canvas" href="#Auto-GUI.main_screen.MainScreen.field_canvas">field_canvas</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.field_image_bounds" href="#Auto-GUI.main_screen.MainScreen.field_image_bounds">field_image_bounds</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.file_menu" href="#Auto-GUI.main_screen.MainScreen.file_menu">file_menu</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.file_name" href="#Auto-GUI.main_screen.MainScreen.file_name">file_name</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.focus_on_input_field" href="#Auto-GUI.main_screen.MainScreen.focus_on_input_field">focus_on_input_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.font_size" href="#Auto-GUI.main_screen.MainScreen.font_size">font_size</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_error_message" href="#Auto-GUI.main_screen.MainScreen.get_error_message">get_error_message</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_index_of_point" href="#Auto-GUI.main_screen.MainScreen.get_index_of_point">get_index_of_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_path_action_point_point_at_path_modifying_point" href="#Auto-GUI.main_screen.MainScreen.get_path_action_point_point_at_path_modifying_point">get_path_action_point_point_at_path_modifying_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_path_action_points_to_reflect_conditions" href="#Auto-GUI.main_screen.MainScreen.get_path_action_points_to_reflect_conditions">get_path_action_points_to_reflect_conditions</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_point_indexes" href="#Auto-GUI.main_screen.MainScreen.get_point_indexes">get_point_indexes</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_points_list" href="#Auto-GUI.main_screen.MainScreen.get_points_list">get_points_list</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_required_point_at_path_modifying_point" href="#Auto-GUI.main_screen.MainScreen.get_required_point_at_path_modifying_point">get_required_point_at_path_modifying_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.get_user_modifiable_fields" href="#Auto-GUI.main_screen.MainScreen.get_user_modifiable_fields">get_user_modifiable_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.handle_input_field_click" href="#Auto-GUI.main_screen.MainScreen.handle_input_field_click">handle_input_field_click</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.image_left_edge" href="#Auto-GUI.main_screen.MainScreen.image_left_edge">image_left_edge</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.image_top_edge" href="#Auto-GUI.main_screen.MainScreen.image_top_edge">image_top_edge</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.initial_and_end_condition_fields" href="#Auto-GUI.main_screen.MainScreen.initial_and_end_condition_fields">initial_and_end_condition_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.initial_angle_field" href="#Auto-GUI.main_screen.MainScreen.initial_angle_field">initial_angle_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.initial_conditions_tab_left_edge" href="#Auto-GUI.main_screen.MainScreen.initial_conditions_tab_left_edge">initial_conditions_tab_left_edge</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.initial_conditions_tab_length" href="#Auto-GUI.main_screen.MainScreen.initial_conditions_tab_length">initial_conditions_tab_length</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.initial_speed_field" href="#Auto-GUI.main_screen.MainScreen.initial_speed_field">initial_speed_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.key_binding_to_function" href="#Auto-GUI.main_screen.MainScreen.key_binding_to_function">key_binding_to_function</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.left_field_canvas" href="#Auto-GUI.main_screen.MainScreen.left_field_canvas">left_field_canvas</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.left_field_image" href="#Auto-GUI.main_screen.MainScreen.left_field_image">left_field_image</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.load_file" href="#Auto-GUI.main_screen.MainScreen.load_file">load_file</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.make_input_field_selection_valid" href="#Auto-GUI.main_screen.MainScreen.make_input_field_selection_valid">make_input_field_selection_valid</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.menu" href="#Auto-GUI.main_screen.MainScreen.menu">menu</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.move_button" href="#Auto-GUI.main_screen.MainScreen.move_button">move_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.next_points_altered" href="#Auto-GUI.main_screen.MainScreen.next_points_altered">next_points_altered</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.paste_point" href="#Auto-GUI.main_screen.MainScreen.paste_point">paste_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_action_point_alterable_fields_frame" href="#Auto-GUI.main_screen.MainScreen.path_action_point_alterable_fields_frame">path_action_point_alterable_fields_frame</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_action_points" href="#Auto-GUI.main_screen.MainScreen.path_action_points">path_action_points</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_action_points_input_fields" href="#Auto-GUI.main_screen.MainScreen.path_action_points_input_fields">path_action_points_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_is_closed_drop_down_menu" href="#Auto-GUI.main_screen.MainScreen.path_is_closed_drop_down_menu">path_is_closed_drop_down_menu</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_line_width" href="#Auto-GUI.main_screen.MainScreen.path_line_width">path_line_width</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_modifying_point_alterable_fields_frame" href="#Auto-GUI.main_screen.MainScreen.path_modifying_point_alterable_fields_frame">path_modifying_point_alterable_fields_frame</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_modifying_point_line_width" href="#Auto-GUI.main_screen.MainScreen.path_modifying_point_line_width">path_modifying_point_line_width</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_modifying_points" href="#Auto-GUI.main_screen.MainScreen.path_modifying_points">path_modifying_points</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.path_modifying_points_input_fields" href="#Auto-GUI.main_screen.MainScreen.path_modifying_points_input_fields">path_modifying_points_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.placement_angle_field" href="#Auto-GUI.main_screen.MainScreen.placement_angle_field">placement_angle_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_action_bar_buttons" href="#Auto-GUI.main_screen.MainScreen.point_action_bar_buttons">point_action_bar_buttons</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_action_bar_height" href="#Auto-GUI.main_screen.MainScreen.point_action_bar_height">point_action_bar_height</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_action_bar_top_edge" href="#Auto-GUI.main_screen.MainScreen.point_action_bar_top_edge">point_action_bar_top_edge</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_alterable_fields_frame" href="#Auto-GUI.main_screen.MainScreen.point_alterable_fields_frame">point_alterable_fields_frame</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_alterable_fields_frames_height" href="#Auto-GUI.main_screen.MainScreen.point_alterable_fields_frames_height">point_alterable_fields_frames_height</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_bar_length" href="#Auto-GUI.main_screen.MainScreen.point_bar_length">point_bar_length</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_click_function" href="#Auto-GUI.main_screen.MainScreen.point_click_function">point_click_function</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_editing_state" href="#Auto-GUI.main_screen.MainScreen.point_editing_state">point_editing_state</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.point_editing_state_to_point_button" href="#Auto-GUI.main_screen.MainScreen.point_editing_state_to_point_button">point_editing_state_to_point_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_altered_to_frame_button_color" href="#Auto-GUI.main_screen.MainScreen.points_altered_to_frame_button_color">points_altered_to_frame_button_color</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_altered_to_frame_name" href="#Auto-GUI.main_screen.MainScreen.points_altered_to_frame_name">points_altered_to_frame_name</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_altered_to_point_alterable_fields_frame" href="#Auto-GUI.main_screen.MainScreen.points_altered_to_point_alterable_fields_frame">points_altered_to_point_alterable_fields_frame</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_altered_to_point_list" href="#Auto-GUI.main_screen.MainScreen.points_altered_to_point_list">points_altered_to_point_list</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_altered_to_points_input_fields" href="#Auto-GUI.main_screen.MainScreen.points_altered_to_points_input_fields">points_altered_to_points_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_input_fields" href="#Auto-GUI.main_screen.MainScreen.points_input_fields">points_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.points_list" href="#Auto-GUI.main_screen.MainScreen.points_list">points_list</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.popup_windows" href="#Auto-GUI.main_screen.MainScreen.popup_windows">popup_windows</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.previous_file_name" href="#Auto-GUI.main_screen.MainScreen.previous_file_name">previous_file_name</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.previous_file_path" href="#Auto-GUI.main_screen.MainScreen.previous_file_path">previous_file_path</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.quick_save_file" href="#Auto-GUI.main_screen.MainScreen.quick_save_file">quick_save_file</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.request_load_file" href="#Auto-GUI.main_screen.MainScreen.request_load_file">request_load_file</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.required_point_alterable_fields_frame" href="#Auto-GUI.main_screen.MainScreen.required_point_alterable_fields_frame">required_point_alterable_fields_frame</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.required_points" href="#Auto-GUI.main_screen.MainScreen.required_points">required_points</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.required_points_input_fields" href="#Auto-GUI.main_screen.MainScreen.required_points_input_fields">required_points_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.reset_all_point_input_fields" href="#Auto-GUI.main_screen.MainScreen.reset_all_point_input_fields">reset_all_point_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.reset_input_fields_button" href="#Auto-GUI.main_screen.MainScreen.reset_input_fields_button">reset_input_fields_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.reset_point_input_fields" href="#Auto-GUI.main_screen.MainScreen.reset_point_input_fields">reset_point_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.right_field_canvas" href="#Auto-GUI.main_screen.MainScreen.right_field_canvas">right_field_canvas</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.right_field_image" href="#Auto-GUI.main_screen.MainScreen.right_field_image">right_field_image</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.run_error_checking" href="#Auto-GUI.main_screen.MainScreen.run_error_checking">run_error_checking</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.run_mouse_click" href="#Auto-GUI.main_screen.MainScreen.run_mouse_click">run_mouse_click</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.save_file" href="#Auto-GUI.main_screen.MainScreen.save_file">save_file</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.save_file_as" href="#Auto-GUI.main_screen.MainScreen.save_file_as">save_file_as</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.save_file_button" href="#Auto-GUI.main_screen.MainScreen.save_file_button">save_file_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.selected_input_field" href="#Auto-GUI.main_screen.MainScreen.selected_input_field">selected_input_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.selected_point" href="#Auto-GUI.main_screen.MainScreen.selected_point">selected_point</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.selected_point_field" href="#Auto-GUI.main_screen.MainScreen.selected_point_field">selected_point_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.set_button_colors" href="#Auto-GUI.main_screen.MainScreen.set_button_colors">set_button_colors</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.swap_points_button" href="#Auto-GUI.main_screen.MainScreen.swap_points_button">swap_points_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.swap_points_function" href="#Auto-GUI.main_screen.MainScreen.swap_points_function">swap_points_function</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.switched_point_field" href="#Auto-GUI.main_screen.MainScreen.switched_point_field">switched_point_field</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.switching_points_bar_height" href="#Auto-GUI.main_screen.MainScreen.switching_points_bar_height">switching_points_bar_height</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.switching_points_bar_top_edge" href="#Auto-GUI.main_screen.MainScreen.switching_points_bar_top_edge">switching_points_bar_top_edge</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.toggle_frame_button" href="#Auto-GUI.main_screen.MainScreen.toggle_frame_button">toggle_frame_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.toggle_frame_button_height" href="#Auto-GUI.main_screen.MainScreen.toggle_frame_button_height">toggle_frame_button_height</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.toggle_points_alterable_fields_frame" href="#Auto-GUI.main_screen.MainScreen.toggle_points_alterable_fields_frame">toggle_points_alterable_fields_frame</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.toolbar_height" href="#Auto-GUI.main_screen.MainScreen.toolbar_height">toolbar_height</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.toolbar_length" href="#Auto-GUI.main_screen.MainScreen.toolbar_length">toolbar_length</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.toolbar_top_edge" href="#Auto-GUI.main_screen.MainScreen.toolbar_top_edge">toolbar_top_edge</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.unselect_input_fields" href="#Auto-GUI.main_screen.MainScreen.unselect_input_fields">unselect_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.update_input_fields" href="#Auto-GUI.main_screen.MainScreen.update_input_fields">update_input_fields</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.update_point_information" href="#Auto-GUI.main_screen.MainScreen.update_point_information">update_point_information</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.update_points" href="#Auto-GUI.main_screen.MainScreen.update_points">update_points</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.update_points_button" href="#Auto-GUI.main_screen.MainScreen.update_points_button">update_points_button</a></code></li>
<li><code><a title="Auto-GUI.main_screen.MainScreen.update_points_to_reflect_loaded_file" href="#Auto-GUI.main_screen.MainScreen.update_points_to_reflect_loaded_file">update_points_to_reflect_loaded_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>